[
  {
    "objectID": "posts/lab_5.html",
    "href": "posts/lab_5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "The goal of this lab was to develop experience with interrupts by using them on our MCU to determine the speed of a motor by reading from a quadrature encoder. As always, the code for this lab can be found in the lab 5 folder of my Github repository for E155."
  },
  {
    "objectID": "posts/lab_5.html#introduction",
    "href": "posts/lab_5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "The goal of this lab was to develop experience with interrupts by using them on our MCU to determine the speed of a motor by reading from a quadrature encoder. As always, the code for this lab can be found in the lab 5 folder of my Github repository for E155."
  },
  {
    "objectID": "posts/lab_5.html#design",
    "href": "posts/lab_5.html#design",
    "title": "Lab 5: Interrupts",
    "section": "Design",
    "text": "Design\n\nBackground\nQuadrature encoders work by using two sensors that are 90 degrees out of phase on a patterned disk to determine how fast the disk rotates. The outputs of these sensors also allow us to determine the direction in which the motor is spinning. We were provided with the information that the motor has a pulses-per-rotation (PPR) of 408. The core of the design is a set of interrupts and handlers that read from the encoder and update a global variable to store the number of ‘ticks’. I also kept track of the previous and current state of the encoder in order to determine the direction it was spinning in, which determined whether tick count was incremented or decremented.\n\n\nSchematic\nThe schematic for this lab was very simple, as the motor could be connected directly to the MCU so long as the encoders were connected to 5V tolerant pins. It was for that reason that I connected the encoders to PA6 and PA8, as those were listed as 5V tolerant by the datasheet.\n\n\n\nSchematic\n\n\n\n\nISR Design\nI designed an Interrupt Service Routine (ISR) to determine the behavior of the MCU when an interrupt is triggered. When an interrupt is triggered by a falling or rising edge of either encoder, the EXTI ISR does the following:\n\nClears the interrupt\nReads the current state\nUpdates a counter for the number of pulses\nStores the current state in a static variable for previous state\nReturns to the program\n\nA flow chart can be seen below:\n\n\n\nflowchart\n\n\nI also used the SysTick interrupt to handle computing the revolutions per second and print the value to the terminal every 0.25s. A description of the SysTick ISR can be seen in the flowchart above.\n\n\nMotor Speed Calculation\nIn order to calculate the speed of the motor, I stored the number of quadrature pulses in a variable called pulse_count. The inputs a and b were taken and used to form a 2-bit value curr_AB, giving values 0-3 for the four valid quadrature states. I stored the previous state in last_AB. By storing the previous state, I enabled my code to determine the transition direction. I then combined the previous and current states into a 4-bit number to represent one of 16 possible transitions. Using a lookup table, I mapped each transition to a forward pulse, reverse pulse, or invalid transition (no motion). So, pulse_count would increment or decrement depending on direction. This pulse_count value would then used in calculateRPS(), which would be called every 250ms. The formula I used for calculated the revolutions per second is as follows:\n\\[\\text{rps} = \\frac{\\text{pulse count}}{PPR \\cdot 4}\\]\nWhere PPR = 408 pulses per revolution."
  },
  {
    "objectID": "posts/lab_5.html#results",
    "href": "posts/lab_5.html#results",
    "title": "Lab 5: Interrupts",
    "section": "Results",
    "text": "Results\n\nPerformance Verification\nTo verify I was reading correct values for the rotations/second of the motor, I measured the outputs of the quadrature encoder using an oscilloscope and calculated the motor’s actual angular rate. The oscilloscope would give me the frequency of the pulses from the quadrature encoder, which can be converted to a rotations/second value through the following equation:\n\\[\\frac{r}{s} = \\frac{f}{PPR}\\]\nWhere PPR = 408.\n\n-10V Input\nMy program reported a motor speed of +2.42 rev/s when I gave the motor -10V. I confirmed the direction visually, as the motor was spinning clockwise. I measured the quadrature signals on an oscilloscope. The signals can be seen below.\n\n\n\n-10V Oscilloscope\n\n\nUsing the pulse frequency of 984Hz (from the image) and the aforementioned equation for rotations/second, I found that actual revolutions/second of the motor to be 2.41 rotations/second.\n\n\n+15V Input\nMy program reported a motor speed of -3.63 rev/s when I gave the motor +15V. I confirmed the direction visually, as the motor was spinning counterclockwise. I measured the quadrature signals on an oscilloscope. The signals can be seen below.\n\n\n\n15V Oscilloscope\n\n\nUsing the pulse frequency of 1.481KHz (from the image) and the aforementioned equation for rotations/second, I found that actual revolutions/second of the motor to be 3.63 rotations/second.\n\n\n+5V Input\nMy program reported a motor speed of -1.14 rev/s when I gave the motor +5V from the MCU. I confirmed the direction visually, as the motor was spinning counterclockwise. I measured the quadrature signals on an oscilloscope. The signals can be seen below.\n\n\n\n5V Oscilloscope\n\n\nUsing the pulse frequency of 463Hz (from the image) and the aforementioned equation for rotations/second, I found that actual revolutions/second of the motor to be 1.13 rotations/second."
  },
  {
    "objectID": "posts/lab_5.html#analysis",
    "href": "posts/lab_5.html#analysis",
    "title": "Lab 5: Interrupts",
    "section": "Analysis",
    "text": "Analysis\nAn alternative approach to designing the system in this lab would be timer-based polling. In order to compare the performance of interrupt vs polling-based approaches, let us consider the following. Define:\n\nLet \\(\\Omega\\) be shaft speed in rev/s\nLet each encoder channel is a square wave with frequency \\(f\\). The channels have equivalent frequencies\nFor the sake of this exercise, let us assume that the square wave produced always has the same frequency \\(f\\), with no random increases or decreases in \\(f\\).\nLet each encoder channel be spaced by 90 degrees with time spacing \\(\\Delta\\). Notice that as \\(f\\) increases, \\(\\Delta\\) decreases\nLet the encoder’s counts per revolution (CPR) be four times the motor’s revolution, as we’re tracking every edge\nLet \\(C\\) be the worst-case execution time for the ISR\nLet \\(T_{Poll}\\) be the worst-case execution time for the polling + loop body\n\nAssume the constraint that the interrupt and polling-based approaches cannot miss a single edge from the quadrature encoder. Define encoder signal period \\(T\\) = 1/\\(f\\). Since the edges are 90 degrees apart, we see the following:\n\\[\\Delta = \\frac{T}{4} = \\frac{1}{4 \\cdot f} = \\frac{1}{4 \\cdot \\frac{\\text{CPR}}{4} \\cdot \\Omega} = \\frac{1}{\\text{CPR} \\cdot \\Omega}\\]\nEquivalently, we have an edge rate \\(\\lambda\\)\n\\[\\lambda = \\frac{1}{\\Delta} = \\text{CPR} \\cdot \\Omega\\]\nSince we have all four edges on one EXTI line, we need to make sure we clear the previous edge before the next one arrives. Otherwise, multiple edges coalesce and we lose an edge. So, we can define our hard bound on worst-case ISR time \\(C\\) as\n\\[C &lt; \\Delta\\]\nIn turn, this tells us the maximum RPS the system can measure is without missing any edges for an arbitrary ISR execution time \\(C_a\\)\n\\[\\text{RPS} &lt; \\frac{1}{\\text{CPR} \\cdot C_a}\\]\nUsing a polling model, to not miss edges and get correct state transitions, we need \\(T_{Poll}\\) &lt; \\(\\Delta\\), where \\(T_{Poll}\\) is our polling period. Also, loop body cycles have to fit within \\(T_{poll}\\). In practice, we’d want to ensure that \\(T_{Poll} &lt; \\Delta / 2\\). But let’s assume we magically optimize our loop body to use the exact amount of clock cycles in \\(T_{Poll}\\). Then, we can see that for an arbitrary poll + loop execution time \\(T_{a}\\), the maximum RPS the system can measure without missing any edges is\n\\[\\text{RPS} &lt; \\frac{1}{\\text{CPR} \\cdot T_{a}}\\]\nNow, assume that \\(C\\) and \\(T_{Poll}\\) are perfectly optimized such that the number of clock cycles required cannot be decreased without losing system functionality. We see that as \\(C\\) and \\(T_{Poll}\\) decrease, the maximum RPS that the system can measure increases. Therefore, the most performant system at high frequencies is the system that uses the least number of clock cycles to maintain system functionality.\nThis was a fun exercise, but it doesn’t consider key aspects of interrupt vs polling-based approaches. There exist advantages to interrupt-based approaches. Interrupt-based routines are more efficent than polling-based approaches, as they allow the MCU to execute other tasks while waiting for the encoder to trigger an interrupt. Also, interrupts can capture the exact moment the encoder changes state. Furthermore, according to Valvano and Yerraballi, \\(C &lt;&lt; T_{Poll}\\) in practice, as ISRs are typically far smaller than any functional polling loop. So, this supports the use of interrupt-based routines for high-frequency edge latching.\nAs a note, there are other approaches to acquiring digital data at high frequencies. For performance-critical systems at very high frequencies, timer input capture or dynamic memory allocation (DMA) can be used to latch every edge in hardware. FPGAs are also better at this than MCUs!"
  },
  {
    "objectID": "posts/lab_5.html#conclusion",
    "href": "posts/lab_5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nI spent 11 hours on this lab."
  },
  {
    "objectID": "posts/lab_5.html#ai-prototype",
    "href": "posts/lab_5.html#ai-prototype",
    "title": "Lab 5: Interrupts",
    "section": "AI Prototype",
    "text": "AI Prototype\nI began by giving ChatGPT 5 the following prompt:\n\n\n\n\n\n\nNote\n\n\n\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\n\n\nGPT5 recommended that I use a hardware timer in encoder mode instead of reading GPIO pins, which I found interesting. It suggested configuring TIM2 such that an over/underflow would cause an interrupt. It also provided the approach I used, but suggested it was a less preferable option. I didn’t find the LLM’s advice particularly useful."
  },
  {
    "objectID": "posts/lab_3.html",
    "href": "posts/lab_3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "The goal of this lab was to learn how to use an FPGA to scan inputs from a keypad, and then output the two most recent inputs on the multiplexed 7-segment display from lab 2. The crux of this lab was ensuring I followed synchronous design principles, as well as designing an FSM that took switch debouncing into account. The lab 3 page of the E155 website has more information about the lab."
  },
  {
    "objectID": "posts/lab_3.html#introduction",
    "href": "posts/lab_3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "The goal of this lab was to learn how to use an FPGA to scan inputs from a keypad, and then output the two most recent inputs on the multiplexed 7-segment display from lab 2. The crux of this lab was ensuring I followed synchronous design principles, as well as designing an FSM that took switch debouncing into account. The lab 3 page of the E155 website has more information about the lab."
  },
  {
    "objectID": "posts/lab_3.html#technical-documentation",
    "href": "posts/lab_3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 3 folder of my Github repository for E155.\n\nCircuit Design\nUnlike previous labs, I began this one by designing my circuits. I made this decision because I felt like doing so would prove beneficial in going through the rest of the lab. The circuit I designed can be seen below. It features two 2N3906 PNP transistors being used to power the 7-segment display. The rational behind my design choices for the circuitry involving the transistors and the 7-segment display can be found in my writeup for lab 2.\nTo design my keypad scanning scheme, I made the initial decision that I would drive the rows of the keypad as outputs and read the columns as inputs. I chose to drive my rows high, which meant that to “select” a row to read I would drive it low (keeping the rest of the rows high) and read the columns. If I pressed a key in the row I was reading, it would short that row and column together, which means that a key press is represented by a low voltage level instead of a high one. I used the internal 100 kOhm resistors on the FPGA to enable this behavior. My pin assignments and general wiring are displayed in the circuits below.\n\n\n\nCircuit\n\n\n\n\nFSM\nThe next step I took was developing my FSM. Initially, I planned on utilizing two completely separate FSMs, one for scanning the rows and one for debouncing once a key was pressed. However, I ended up combining my initial two ideas into one big FSM, which can be seen below. In the FSM, a 1 represents a key press being detected and a 0 represents no keys being pressed. I used a counter to keep track of how many clock cycles had passed, with the counter incrementing each clock cycle. In order to deal with the delay from the synchronizer, the FSM stays in the BUFFER states for two clock cycles, which is how long it takes my synchronizer to synchronize the inputs. Whenever the FSM enters any of the ROW, PULSE, or WAIT states, the counter is reset to 0. To solve debouncing, I have the counter increment by 1 per clock cycle if it’s in a DEBOUNCE state. Once counter has incremented 16 times (counter = 15), the transition can be made to the PULSE state if the key is still pressed. In the PULSE state, the FSM sends a signal called PRESS to my next-state logic. PRESS serves as a select signal to determine whether or not a new key has been pressed, which then enables the updating of the 7-segment display. My full FSM can be seen below, as well as its associated state transition table.\n\n\n\nFSM\n\n\n\n\n\nTruth Table\n\n\n\n\nBlock Diagram + Verilog Design\nImplementing this design required 9 separate SystemVerilog modules, including the top-level module and the built-in HSOSC module for clock generation. After initializing a clock to 24 MHz using the HSOSC module, I divided the clock down to 1.2 kHz using a module of my own design. This new “slow clock” then became the system-level clock. The modules for controlling the 7-segment display were taken from lab 2, although the multiplexer module was modified to divide the clock by a factor of two instead of 2^15. This meant that the 7-segment display has a refresh rate of 600Hz, which is sufficient to not notice flickering. I chose a 1.2kHz clock so that once the FSM went through the 16 debounce clock cycles, there would be no risk that the switch was bouncing. This also meant that a button would need to be pressed for approximately 13 ms to be recognized as pressed, which I felt was reasonable. The block diagram for my system can be seen below.\n\n\n\nBlock Diagram\n\n\n\n\nWaveforms\nBefore testing my physical system, I wrote testbenches for all of my modules (except for the 7-segment display logic module, which has been the same since lab 1). This meant that once it was time to build my physical system, I was able to get it working quickly. The waveforms and testbench output for my top-level module can be seen below. The Waveform Gallery can be expanded to view the waveforms and testbench output for the rest of my modules.\n\n\n\nTop Level Module Testbench Waveforms\n\n\n\n\n\nTop Level Module Testbench Output\n\n\n\n\n\n\n\n\nWaveform Gallery\n\n\n\n\n\n\n\n\nKeypad Decoder Testbench Waveforms\n\n\n\n\n\nKeypad Decoder Testbench Output\n\n\n\n\n\nKeypad Input Testbench Waveforms\n\n\n\n\n\nKeypad Input Testbench Output\n\n\n\n\n\nKeypad Reader Testbench Waveforms\n\n\n\n\n\nKeypad Reader Testbench Output\n\n\n\n\n\nSeven Segment Controller Testbench Waveforms\n\n\n\n\n\nSeven Segment Controller Testbench Output\n\n\n\n\n\nSynchronizer Testbench Waveforms\n\n\n\n\n\nSynchronizer Testbench Output\n\n\n\n\n\n\n\nConclusion\nThe design meets all the requirements. I spent somewhere between 25 and 30 hours on this lab.\n\n\nAI Prototype\nI began by giving ChatGPT 5 the following prompt:\n\n\n\n\n\n\nLLM Prompt: Whole Lab (Monolithic)\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4×4 matrix keypad and display the last two hex keys pressed on a dual 7-segment display. Implement:\n\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator.\nA keypad scanning controller that iterates one active-low column at a time and samples active-low rows, registering at most one key per press (debounce-by-design), ignoring additional presses while any key is held, and allowing a new registration only after release.\nA top level that updates two hex digits (older and most recent) when a new key is registered and drives a time-multiplexed two-digit 7-segment display without visible flicker and with balanced brightness.\n\nUse idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\n\nGPT5 thought for 34 seconds and produced an absolute wall of SystemVerilog, which can be seen in the code block below.\n\n\n\n\n\n\nCode (Click to Expand)\n\n\n\n\n\n// ============================================================================\n// Clock divider: generates one-cycle enable pulses at requested rates.\n// - All state is synchronous to 'clk'.\n// - Produces 'scan_tick'  ~150 Hz (for keypad scan) and\n//           'refresh_tick'~1 kHz (for 2-digit display multiplexing).\n// Adjust parameters to taste / your exact oscillator.\n// ============================================================================\nmodule clock_divider #(\n    parameter int unsigned CLK_HZ        = 20_000_000,\n    parameter int unsigned SCAN_HZ       = 150,     // ~100–200 Hz good for scan\n    parameter int unsigned REFRESH_HZ    = 1_000    // ~1 kHz for 2-digit mux\n) (\n    input  logic clk,\n    input  logic rst_n,            // active-low synchronous reset\n    output logic scan_tick,        // 1-cycle pulse at SCAN_HZ\n    output logic refresh_tick      // 1-cycle pulse at REFRESH_HZ\n);\n    // Compute terminal counts (&gt;=1)\n    localparam int unsigned SCAN_TERM    = (CLK_HZ/SCAN_HZ)    &gt; 0 ? (CLK_HZ/SCAN_HZ)    : 1;\n    localparam int unsigned REFRESH_TERM = (CLK_HZ/REFRESH_HZ) &gt; 0 ? (CLK_HZ/REFRESH_HZ) : 1;\n\n    // Sized counters (sized large enough using $clog2)\n    logic [$clog2(SCAN_TERM   )-1:0] scan_cnt;\n    logic [$clog2(REFRESH_TERM)-1:0] ref_cnt;\n\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            scan_cnt    &lt;= '0;\n            ref_cnt     &lt;= '0;\n            scan_tick   &lt;= 1'b0;\n            refresh_tick&lt;= 1'b0;\n        end else begin\n            // scan tick\n            if (scan_cnt == SCAN_TERM-1) begin\n                scan_cnt  &lt;= '0;\n                scan_tick &lt;= 1'b1;\n            end else begin\n                scan_cnt  &lt;= scan_cnt + 1'b1;\n                scan_tick &lt;= 1'b0;\n            end\n            // refresh tick\n            if (ref_cnt == REFRESH_TERM-1) begin\n                ref_cnt       &lt;= '0;\n                refresh_tick  &lt;= 1'b1;\n            end else begin\n                ref_cnt       &lt;= ref_cnt + 1'b1;\n                refresh_tick  &lt;= 1'b0;\n            end\n        end\n    end\nendmodule\n\n// ============================================================================\n// Keypad scanner for a 4x4 active-low matrix.\n// Columns (outputs) are driven one-at-a-time low; rows (inputs) are sampled.\n// \"Debounce-by-design\":\n//   - Register a key only on transition from \"no key\" -&gt; \"some key\".\n//   - While any key is held, ignore further presses (stay in HELD).\n//   - Only after all keys released do we allow a new key registration.\n// Notes:\n//   * col_n[3:0] are ACTIVE-LOW drives. One is 0, others 1.\n//   * row_n[3:0] are ACTIVE-LOW inputs (use pull-ups).\n// ============================================================================\nmodule keypad_scanner (\n    input  logic       clk,\n    input  logic       rst_n,         // synchronous active-low reset\n    input  logic       scan_tick,     // slow tick (~100–200 Hz)\n    output logic [3:0] col_n,         // drive to keypad columns (active-low)\n    input  logic [3:0] row_n,         // read from keypad rows (active-low)\n    output logic       key_new,       // 1 when a new keycode is registered\n    output logic [3:0] key_hex        // 0..F per mapping below\n);\n    // Round-robin column index 0..3\n    logic [1:0] col_idx;\n\n    // FSM states\n    typedef enum logic [1:0] {\n        SCAN,   // normal scanning; if any key is seen, capture once\n        HELD    // at least one key is held; wait for full release\n    } state_e;\n\n    state_e state, state_n;\n\n    // Drive columns: active-low one-hot from col_idx\n    always_comb begin\n        col_n = 4'b1111;\n        col_n[col_idx] = 1'b0; // selected column pulled low\n    end\n\n    // Sample current rows and detect any press at current column\n    logic any_row_low;\n    logic [1:0] row_idx;      // which row is low when pressed (priority-encode)\n\n    always_comb begin\n        // any row asserted low?\n        any_row_low = (row_n != 4'b1111);\n        // simple priority encoder (row0 highest)\n        unique casez (row_n)\n            4'b1110: row_idx = 2'd0; // row0 low\n            4'b1101: row_idx = 2'd1; // row1 low\n            4'b1011: row_idx = 2'd2; // row2 low\n            4'b0111: row_idx = 2'd3; // row3 low\n            default: row_idx = 2'd0; // don't care when none\n        endcase\n    end\n\n    // Hex map for a common 4x4 hex keypad layout:\n    //   Row0: 1 2 3 A\n    //   Row1: 4 5 6 B\n    //   Row2: 7 8 9 C\n    //   Row3: E 0 F D\n    //\n    // key_hex = {row,col} mapped to 0..F\n    function automatic logic [3:0] map_hex(input logic [1:0] r, input logic [1:0] c);\n        unique case ({r,c})\n            4'b00_00: map_hex = 4'h1;\n            4'b00_01: map_hex = 4'h2;\n            4'b00_10: map_hex = 4'h3;\n            4'b00_11: map_hex = 4'hA;\n\n            4'b01_00: map_hex = 4'h4;\n            4'b01_01: map_hex = 4'h5;\n            4'b01_10: map_hex = 4'h6;\n            4'b01_11: map_hex = 4'hB;\n\n            4'b10_00: map_hex = 4'h7;\n            4'b10_01: map_hex = 4'h8;\n            4'b10_10: map_hex = 4'h9;\n            4'b10_11: map_hex = 4'hC;\n\n            4'b11_00: map_hex = 4'hE;\n            4'b11_01: map_hex = 4'h0;\n            4'b11_10: map_hex = 4'hF;\n            4'b11_11: map_hex = 4'hD;\n\n            default:  map_hex = 4'h0;\n        endcase\n    endfunction\n\n    // Registers\n    logic       key_new_r;\n    logic [3:0] key_hex_r;\n\n    // Next-state logic\n    always_comb begin\n        state_n  = state;\n        key_new_r= 1'b0;  // default (pulse)\n        // state machine advances/samples only on scan_tick\n        if (scan_tick) begin\n            unique case (state)\n                SCAN: begin\n                    // if a key is seen on the active column, capture once\n                    if (any_row_low) begin\n                        key_new_r = 1'b1;\n                        // capture code based on (row_idx, col_idx)\n                        // Note: col_idx is which column we are currently driving low\n                    end\n                    // Move to HELD whenever any key is held (in any column).\n                    // We’ll also step col_idx below, so within a few ticks\n                    // we’ll see any held key regardless of which column it’s on.\n                    state_n = any_row_low ? HELD : SCAN;\n                end\n                HELD: begin\n                    // Wait until *all* rows are high (no key pressed)\n                    state_n = (row_n == 4'b1111) ? SCAN : HELD;\n                end\n                default: state_n = SCAN;\n            endcase\n        end\n    end\n\n    // Sequential: advance column round-robin and update outputs\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            state    &lt;= SCAN;\n            col_idx  &lt;= 2'd0;\n            key_new  &lt;= 1'b0;\n            key_hex  &lt;= 4'h0;\n        end else begin\n            state &lt;= state_n;\n\n            // Column stepping at scan rate for stable sampling\n            if (scan_tick) begin\n                col_idx &lt;= col_idx + 2'd1;\n            end\n\n            // Latch new key (pulse output)\n            key_new &lt;= key_new_r;\n            if (scan_tick && key_new_r) begin\n                key_hex &lt;= map_hex(row_idx, col_idx);\n            end\n        end\n    end\nendmodule\n\n// ============================================================================\n// Hex to 7-seg (a..g) decoder.\n// Default assumes active-low segments (common-anode display).\n// Set ACTIVE_LOW=0 if your segments are active-high (common-cathode).\n// ============================================================================\nmodule hex7seg #(\n    parameter bit ACTIVE_LOW = 1'b1\n) (\n    input  logic [3:0] hex,\n    output logic [6:0] seg    // seg[6:0] = {a,b,c,d,e,f,g}\n);\n    // Active-HIGH pattern for segments (1 = on) for 0..F\n    logic [6:0] seg_on;\n    always_comb begin\n        unique case (hex)\n            4'h0: seg_on = 7'b1111110;\n            4'h1: seg_on = 7'b0110000;\n            4'h2: seg_on = 7'b1101101;\n            4'h3: seg_on = 7'b1111001;\n            4'h4: seg_on = 7'b0110011;\n            4'h5: seg_on = 7'b1011011;\n            4'h6: seg_on = 7'b1011111;\n            4'h7: seg_on = 7'b1110000;\n            4'h8: seg_on = 7'b1111111;\n            4'h9: seg_on = 7'b1111011;\n            4'hA: seg_on = 7'b1110111;\n            4'hB: seg_on = 7'b0011111; // lower-case b\n            4'hC: seg_on = 7'b1001110;\n            4'hD: seg_on = 7'b0111101; // lower-case d\n            4'hE: seg_on = 7'b1001111;\n            4'hF: seg_on = 7'b1000111;\n            default: seg_on = 7'b0000000;\n        endcase\n    end\n    // Apply polarity\n    always_comb begin\n        seg = ACTIVE_LOW ? ~seg_on : seg_on;\n    end\nendmodule\n\n// ============================================================================\n// Two-digit 7-seg multiplexer.\n// - Alternates between DIG0 and DIG1 at ~1 kHz total (each ~500 Hz).\n// - Balanced duty cycle for uniform brightness.\n// - ACTIVE_LOW_DIG=1 for common-anode digit enables (active-low).\n// - ACTIVE_LOW_SEG passed through to hex7seg.\n// ============================================================================\nmodule sevenseg_mux #(\n    parameter bit ACTIVE_LOW_DIG = 1'b1,\n    parameter bit ACTIVE_LOW_SEG = 1'b1\n) (\n    input  logic       clk,\n    input  logic       rst_n,\n    input  logic       refresh_tick,  // ~1 kHz\n    input  logic [3:0] hex0,          // rightmost / most-recent\n    input  logic [3:0] hex1,          // left / older\n    output logic [6:0] seg,           // segments a..g\n    output logic [1:0] dig_en         // digit enables [1]=left, [0]=right\n);\n    // Which digit is currently active: 0=right(hex0), 1=left(hex1)\n    logic sel;\n\n    // Toggle selection on each refresh tick\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            sel &lt;= 1'b0;\n        end else if (refresh_tick) begin\n            sel &lt;= ~sel;\n        end\n    end\n\n    // Decode currently selected hex\n    logic [3:0] hex_sel = sel ? hex1 : hex0;\n    hex7seg #(.ACTIVE_LOW(ACTIVE_LOW_SEG)) DEC (\n        .hex(hex_sel),\n        .seg(seg)\n    );\n\n    // Drive digit enables with proper polarity, one at a time\n    always_comb begin\n        logic [1:0] on = (sel ? 2'b10 : 2'b01); // left or right\n        dig_en = ACTIVE_LOW_DIG ? ~on : on;\n    end\nendmodule\n\n// ============================================================================\n// Top-level: tie everything together.\n// - Takes ~20 MHz 'clk' (from UP5K HFOSC; instantiate separately in your top or\n//   wrap this in your board-level top that instantiates SB_HFOSC).\n// - Exposes keypad col (outputs, active-low) and row (inputs, active-low).\n// - Shows last two keys: left=older, right=most recent.\n// ============================================================================\nmodule keypad_two_digit_top #(\n    // Tune these for your oscillator if needed\n    parameter int unsigned CLK_HZ      = 20_000_000,\n    parameter bit ACTIVE_LOW_SEGMENTS  = 1'b1, // common-anode default\n    parameter bit ACTIVE_LOW_DIGITS    = 1'b1  // common-anode default\n) (\n    input  logic       clk,         // ~20 MHz\n    input  logic       rst_n,       // synchronous active-low reset\n    // Keypad interface (active-low)\n    output logic [3:0] kp_col_n,    // drive columns\n    input  logic [3:0] kp_row_n,    // read rows (enable pull-ups)\n    // 7-seg display (two digits)\n    output logic [6:0] seg,         // a..g (active-low by default)\n    output logic [1:0] dig_en       // [1]=left, [0]=right (active-low by default)\n);\n    // ------------------------------------------------------------------------\n    // Clocks: scan + refresh ticks\n    // ------------------------------------------------------------------------\n    logic scan_tick, refresh_tick;\n    clock_divider #(\n        .CLK_HZ     (CLK_HZ),\n        .SCAN_HZ    (150),\n        .REFRESH_HZ (1_000)\n    ) CLKDIV (\n        .clk         (clk),\n        .rst_n       (rst_n),\n        .scan_tick   (scan_tick),\n        .refresh_tick(refresh_tick)\n    );\n\n    // ------------------------------------------------------------------------\n    // Keypad scanner\n    // ------------------------------------------------------------------------\n    logic       key_new;\n    logic [3:0] key_hex;\n\n    keypad_scanner SCAN (\n        .clk     (clk),\n        .rst_n   (rst_n),\n        .scan_tick(scan_tick),\n        .col_n   (kp_col_n),\n        .row_n   (kp_row_n),\n        .key_new (key_new),\n        .key_hex (key_hex)\n    );\n\n    // ------------------------------------------------------------------------\n    // Last-two key register: shift most-recent -&gt; left, new -&gt; right\n    // - On key_new, shift: older &lt;= recent; recent &lt;= key_hex.\n    // - Reset clears both to 0.\n// ------------------------------------------------------------------------\n    logic [3:0] recent_hex, older_hex;\n\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            recent_hex &lt;= 4'h0;\n            older_hex  &lt;= 4'h0;\n        end else if (key_new) begin\n            older_hex  &lt;= recent_hex;\n            recent_hex &lt;= key_hex;\n        end\n    end\n\n    // ------------------------------------------------------------------------\n    // 7-seg two-digit mux (left=older, right=recent)\n    // ------------------------------------------------------------------------\n    sevenseg_mux #(\n        .ACTIVE_LOW_DIG (ACTIVE_LOW_DIGITS),\n        .ACTIVE_LOW_SEG (ACTIVE_LOW_SEGMENTS)\n    ) MUX (\n        .clk         (clk),\n        .rst_n       (rst_n),\n        .refresh_tick(refresh_tick),\n        .hex0        (recent_hex),  // right (most-recent)\n        .hex1        (older_hex),   // left (older)\n        .seg         (seg),\n        .dig_en      (dig_en)\n    );\nendmodule\n\n\n\nThe SystemVerilog synthesized in Lattice Radiant. I personally would never put all my modules in one file like this as it seems hellish to debug, but I’m impressed that it synthesized succesfully.\nThe next step was creating a new session with GPT5 and giving it the following prompt:\n\n\n\n\n\n\nLLM Prompt 1: One‑shot Registration (Debounce‑by‑design)\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\n\n\nGPT5 thought for 47 seconds and produced the following output.\n\n\n\n\n\n\nPrompt 1 Output (Click to Expand)\n\n\n\n\n\n// One-shot key registrar with symmetric press/release debounce\nmodule keypad_one_shot #(\n  parameter int DEBOUNCE_CYCLES = 2_000   // tune to your scan/system clock\n)(\n  input  logic        clk,                // system clock\n  input  logic        reset,              // synchronous, active-high\n  input  logic        any_key,            // 1 if any key currently detected\n  input  logic [3:0]  key_code_in,        // decoded key code from scanner (hex 0..F)\n\n  output logic        new_key_pulse,      // 1-cycle pulse when a new key is registered\n  output logic [3:0]  key_code,           // latched code corresponding to the pulse\n  output logic        busy                 // 1 while we're holding until release\n);\n\n  // FSM states\n  typedef enum logic [2:0] {\n    S_IDLE,            // no key; waiting\n    S_DB_PRESS,        // debouncing a candidate press\n    S_REGISTER,        // single cycle: assert pulse, latch code\n    S_HELD,            // key is pressed and accepted; ignore changes\n    S_DB_RELEASE       // debouncing release\n  } state_t;\n\n  state_t state, state_n;\n\n  // Debounce counter\n  localparam int CW = (DEBOUNCE_CYCLES &lt;= 1) ? 1 : $clog2(DEBOUNCE_CYCLES);\n  logic [CW-1:0] cnt, cnt_n;\n\n  // Candidate code to be validated during press debounce\n  logic [3:0] candidate_code, candidate_code_n;\n\n  // Outputs (registered)\n  logic        new_key_pulse_n;\n  logic [3:0]  key_code_n;\n  logic        busy_n;\n\n  // Combinational next-state / next-data logic\n  always_comb begin\n    // Defaults: hold current values\n    state_n          = state;\n    cnt_n            = cnt;\n    candidate_code_n = candidate_code;\n    key_code_n       = key_code;\n    new_key_pulse_n  = 1'b0;     // pulse only in S_REGISTER\n    busy_n           = (state == S_HELD) || (state == S_DB_RELEASE);\n\n    unique case (state)\n      // ------------------------------------------------------------\n      S_IDLE: begin\n        cnt_n = '0;\n        busy_n = 1'b0;\n        if (any_key) begin\n          candidate_code_n = key_code_in; // capture first seen key\n          state_n = S_DB_PRESS;\n          cnt_n   = '0;\n        end\n      end\n\n      // ------------------------------------------------------------\n      // Require 'any_key' to remain high AND code to remain stable\n      // for DEBOUNCE_CYCLES clocks before accepting the press.\n      S_DB_PRESS: begin\n        if (!any_key) begin\n          state_n = S_IDLE;                 // bounced low; start over\n          cnt_n   = '0;\n        end else if (key_code_in != candidate_code) begin\n          candidate_code_n = key_code_in;   // key changed mid-bounce; restart\n          cnt_n            = '0;\n        end else if (cnt == DEBOUNCE_CYCLES-1) begin\n          state_n = S_REGISTER;             // stable press achieved\n          cnt_n   = '0;\n        end else begin\n          cnt_n = cnt + 1'b1;\n        end\n      end\n\n      // ------------------------------------------------------------\n      // One-cycle registration: latch code and assert pulse.\n      S_REGISTER: begin\n        key_code_n      = candidate_code;\n        new_key_pulse_n = 1'b1;\n        state_n         = S_HELD;\n      end\n\n      // ------------------------------------------------------------\n      // Stay here as long as ANY key is down; ignore changes.\n      S_HELD: begin\n        if (!any_key) begin\n          state_n = S_DB_RELEASE;  // start release debounce\n          cnt_n   = '0;\n        end\n      end\n\n      // ------------------------------------------------------------\n      // Require 'any_key' to remain low for DEBOUNCE_CYCLES clocks\n      // before allowing the next press to be recognized.\n      S_DB_RELEASE: begin\n        if (any_key) begin\n          state_n = S_HELD;        // bounce back high: keep holding\n          cnt_n   = '0;\n        end else if (cnt == DEBOUNCE_CYCLES-1) begin\n          state_n = S_IDLE;        // fully released; ready for next key\n          cnt_n   = '0;\n        end else begin\n          cnt_n = cnt + 1'b1;\n        end\n      end\n\n      default: state_n = S_IDLE;\n    endcase\n  end\n\n  // Sequential state/data registers (glitch-free outputs)\n  always_ff @(posedge clk) begin\n    if (reset) begin\n      state          &lt;= S_IDLE;\n      cnt            &lt;= '0;\n      candidate_code &lt;= '0;\n      key_code       &lt;= '0;\n      new_key_pulse  &lt;= 1'b0;\n      busy           &lt;= 1'b0;\n    end else begin\n      state          &lt;= state_n;\n      cnt            &lt;= cnt_n;\n      candidate_code &lt;= candidate_code_n;\n      key_code       &lt;= key_code_n;\n      new_key_pulse  &lt;= new_key_pulse_n;\n      busy           &lt;= busy_n;\n    end\n  end\n\nendmodule\n\n\n\nI then gave GPT5 the following prompt within the same session:\n\n\n\n\n\n\nLLM Prompt 2: Keypad Scanner Controller\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\n\n\nGPT5 thought for 53 seconds and produced the following SystemVerilog:\n\n\n\n\n\n\nPrompt 2 Output (Click to Expand)\n\n\n\n\n\n//------------------------------------------------------------------------------\n// Keypad Scanner for 4x4 matrix (active-low columns and rows)\n// - Rotates columns one at a time (active-low one-hot)\n// - Samples rows (active-low) after a settle delay\n// - Recognizes exactly one key; latches its code and holds it while pressed\n// - Ignores additional keys until release (single-key-at-a-time policy)\n// - Debounce-lite via \"settle\" after column change; full debouncing is\n//   typically done by the downstream one-shot registrar.\n//------------------------------------------------------------------------------\n// Layout (rows top-&gt;bottom, cols left-&gt;right):\n//   [ 1   2   3   A ]   -&gt;  1,2,3,10\n//   [ 4   5   6   B ]   -&gt;  4,5,6,11\n//   [ 7   8   9   C ]   -&gt;  7,8,9,12\n//   [ *   0   #   D ]   -&gt; 14,0,15,13\n//\n// Active-low wiring expectations:\n// - 'cols' outputs: exactly one bit 0 at a time (others 1)\n// - 'rows_in' inputs: pulled up; pressed key drives its row LOW when\n//   its column is currently driven LOW.\n//------------------------------------------------------------------------------\nmodule keypad_scanner #(\n  // Clock divider: number of clk cycles per column dwell.\n  // Choose to achieve ~1-2 kHz per column (4-8 kHz full-frame) typically.\n  parameter int unsigned COL_DWELL_CYCLES = 2_000,  // tune for your clk\n  // Cycles to wait after changing column before sampling rows (settle time)\n  parameter int unsigned SETTLE_CYCLES    = 4\n) (\n  input  logic        clk,\n  input  logic        reset,            // synchronous, active-high\n\n  // Matrix I/O (external pull-ups on rows recommended; iCE40 internal okay)\n  output logic [3:0]  cols,             // active-low, one-hot\n  input  logic [3:0]  rows_in,          // active-low from keypad\n\n  // Scanner result (level-sensitive)\n  output logic        any_key,          // 1 while a single key is held\n  output logic [3:0]  key_code          // hex code per mapping above\n);\n\n  // -------------------------\n  // Utility: count width calc\n  // -------------------------\n  localparam int CW_DWELL  = (COL_DWELL_CYCLES &lt;= 1) ? 1 : $clog2(COL_DWELL_CYCLES);\n  localparam int CW_SETTLE = (SETTLE_CYCLES    &lt;= 1) ? 1 : $clog2(SETTLE_CYCLES);\n\n  // -------------------------\n  // Row input synchronizers\n  // -------------------------\n  logic [3:0] rows_meta, rows_sync;   // still active-low\n\n  always_ff @(posedge clk) begin\n    rows_meta &lt;= rows_in;\n    rows_sync &lt;= rows_meta;\n  end\n\n  // -------------------------\n  // Column scan machinery\n  // -------------------------\n  typedef enum logic [1:0] { C0=2'd0, C1=2'd1, C2=2'd2, C3=2'd3 } col_t;\n\n  col_t            col_cur, col_next;\n  logic [CW_DWELL-1:0] dwell_cnt;\n  logic [CW_SETTLE-1:0] settle_cnt;\n  logic                settle_done;\n\n  // One-hot, active-low column drive\n  function automatic logic [3:0] col_onehot_n (col_t c);\n    case (c)\n      C0: col_onehot_n = 4'b1110; // drive col0 low\n      C1: col_onehot_n = 4'b1101; // drive col1 low\n      C2: col_onehot_n = 4'b1011; // drive col2 low\n      default: col_onehot_n = 4'b0111; // C3\n    endcase\n  endfunction\n\n  // Advance dwell / settle counters and column index\n  always_ff @(posedge clk) begin\n    if (reset) begin\n      col_cur     &lt;= C0;\n      dwell_cnt   &lt;= '0;\n      settle_cnt  &lt;= '0;\n    end else begin\n      // dwell counter drives column duration\n      if (dwell_cnt == COL_DWELL_CYCLES-1) begin\n        dwell_cnt  &lt;= '0;\n        settle_cnt &lt;= '0;\n        col_cur    &lt;= (col_cur == C3) ? C0 : col_t'(col_cur + 2'd1);\n      end else begin\n        dwell_cnt &lt;= dwell_cnt + 1'b1;\n        // let settle count rise only at start of dwell (i.e., after column change)\n        if (settle_cnt != SETTLE_CYCLES-1)\n          settle_cnt &lt;= settle_cnt + 1'b1;\n      end\n    end\n  end\n\n  assign settle_done = (settle_cnt == SETTLE_CYCLES-1);\n  assign cols        = col_onehot_n(col_cur);\n\n  // -------------------------\n  // Row decode helpers\n  // -------------------------\n  // Return 1 if exactly one row is low; also provide its index.\n  function automatic logic one_low_and_index (\n    input  logic [3:0] rows_n,     // active-low\n    output logic [1:0] row_idx\n  );\n    // invert to active-high for counting\n    logic [3:0] rh = ~rows_n;\n    unique case (rh)\n      4'b0001: begin row_idx = 2'd0; one_low_and_index = 1'b1; end\n      4'b0010: begin row_idx = 2'd1; one_low_and_index = 1'b1; end\n      4'b0100: begin row_idx = 2'd2; one_low_and_index = 1'b1; end\n      4'b1000: begin row_idx = 2'd3; one_low_and_index = 1'b1; end\n      default: begin row_idx = 2'd0; one_low_and_index = 1'b0; end\n    endcase\n  endfunction\n\n  // Map (row, col) -&gt; hex code per the standard 4x4 layout above.\n  function automatic logic [3:0] encode_key (input logic [1:0] r, input col_t c);\n    unique case ({r,c})\n      // row 0\n      {2'd0,C0}: encode_key = 4'h1;\n      {2'd0,C1}: encode_key = 4'h2;\n      {2'd0,C2}: encode_key = 4'h3;\n      {2'd0,C3}: encode_key = 4'hA; // A\n      // row 1\n      {2'd1,C0}: encode_key = 4'h4;\n      {2'd1,C1}: encode_key = 4'h5;\n      {2'd1,C2}: encode_key = 4'h6;\n      {2'd1,C3}: encode_key = 4'hB; // B\n      // row 2\n      {2'd2,C0}: encode_key = 4'h7;\n      {2'd2,C1}: encode_key = 4'h8;\n      {2'd2,C2}: encode_key = 4'h9;\n      {2'd2,C3}: encode_key = 4'hC; // C\n      // row 3\n      {2'd3,C0}: encode_key = 4'hE; // *\n      {2'd3,C1}: encode_key = 4'h0; // 0\n      {2'd3,C2}: encode_key = 4'hF; // #\n      {2'd3,C3}: encode_key = 4'hD; // D\n      default:   encode_key = 4'h0;\n    endcase\n  endfunction\n\n  // -------------------------\n  // Scanner / Hold FSM\n  // -------------------------\n  typedef enum logic [1:0] { S_SCAN, S_CANDIDATE, S_HELD } state_t;\n  state_t state, state_n;\n\n  // Latched/held key info\n  logic [3:0]  key_code_q, key_code_n;\n  col_t        held_col_q, held_col_n;\n  logic [1:0]  held_row_q, held_row_n;\n  logic        any_key_q,  any_key_n;\n\n  // Combinational next-state logic\n  always_comb begin\n    state_n      = state;\n    key_code_n   = key_code_q;\n    held_col_n   = held_col_q;\n    held_row_n   = held_row_q;\n    any_key_n    = any_key_q;\n\n    // defaults: remain in current conditions\n    logic [1:0] sampled_row;\n    logic       single_low = 1'b0;\n\n    // Only trust rows after settle in the current column\n    if (settle_done)\n      single_low = one_low_and_index(rows_sync, sampled_row);\n\n    unique case (state)\n      // ----------------------------------------------------------\n      // SCAN: rotate columns; when exactly one row is low at a\n      // settled sample, accept it as candidate and move to HELD.\n      S_SCAN: begin\n        any_key_n = 1'b0;\n        if (settle_done && single_low) begin\n          held_col_n = col_cur;\n          held_row_n = sampled_row;\n          key_code_n = encode_key(sampled_row, col_cur);\n          any_key_n  = 1'b1;\n          state_n    = S_HELD;\n        end\n      end\n\n      // (unused placeholder state if you later add multi-sample debouncing)\n      S_CANDIDATE: begin\n        state_n = S_SCAN;\n      end\n\n      // ----------------------------------------------------------\n      // HELD: keep reporting the same key as long as, when we come\n      // back to its column and take a settled sample, its row is\n      // still the only low bit. Release when it's not.\n      S_HELD: begin\n        any_key_n  = 1'b1;\n        // Only judge release when we're visiting the owning column\n        if (col_cur == held_col_q && settle_done) begin\n          // pressed if exactly that one row is low\n          if (!(single_low && (sampled_row == held_row_q))) begin\n            // treat as released (or ambiguous) -&gt; go back to SCAN\n            any_key_n = 1'b0;\n            state_n   = S_SCAN;\n          end\n        end\n      end\n\n      default: state_n = S_SCAN;\n    endcase\n  end\n\n  // Sequential registers\n  always_ff @(posedge clk) begin\n    if (reset) begin\n      state      &lt;= S_SCAN;\n      key_code_q &lt;= '0;\n      held_col_q &lt;= C0;\n      held_row_q &lt;= 2'd0;\n      any_key_q  &lt;= 1'b0;\n    end else begin\n      state      &lt;= state_n;\n      key_code_q &lt;= key_code_n;\n      held_col_q &lt;= held_col_n;\n      held_row_q &lt;= held_row_n;\n      any_key_q  &lt;= any_key_n;\n    end\n  end\n\n  // Registered outputs (glitch-free)\n  assign key_code = key_code_q;\n  assign any_key  = any_key_q;\n\nendmodule\n\n\n\nFinally, I gave GPT5 the following prompt (again within the same session):\n\n\n\n\n\n\nLLM Prompt 3: Integrate and Display\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\n\nGPT5 thought for 52 seconds and produced the following output:\n\n\n\n\n\n\nPrompt 3 Output (Click to Expand)\n\n\n\n\n\n//------------------------------------------------------------------------------\n// Top-level: keypad -&gt; one-shot -&gt; 2-digit seven-seg display\n// Target: Lattice iCE40 UP5K (uses SB_HFOSC @ ~12 MHz)\n// Assumptions:\n//   - 4x4 keypad: rows/cols are ACTIVE-LOW (pull-ups enabled on rows).\n//   - 'sevenSegment' module exists:  input [3:0] hex, output [6:0] seg_hi\n//     (active-HIGH segments a..g). We invert if hardware needs active-LOW.\n//   - Digit enables are ACTIVE-LOW (common-anode digits). Invert as needed.\n//------------------------------------------------------------------------------\nmodule keypad_display_top (\n  // Keypad matrix I/O (active-low)\n  output logic [3:0] cols,        // drive columns (exactly one 0 at a time)\n  input  logic [3:0] rows,        // read rows (0 = pressed) with pull-ups\n\n  // Seven-segment display I/O\n  output logic [6:0] seg_n,       // segments a..g, ACTIVE-LOW to the board\n  output logic [1:0] digit_n,     // digit enables {left,right}, ACTIVE-LOW\n\n  // Optional external reset (active-high). Tie low if unused.\n  input  logic       ext_reset\n);\n\n  // ---------------------------------------------------------------------------\n  // Root clock: iCE40 HFOSC @ ~12 MHz (CLKHF_DIV=\"0b10\")\n  // ---------------------------------------------------------------------------\n  logic clk_12m;\n  logic hfosc_en = 1'b1;\n\n  SB_HFOSC #(\n    .CLKHF_DIV(\"0b10\")            // 48:00, 24:01, 12:10, 6:11  (binary)\n  ) u_hfosc (\n    .CLKHFPU(hfosc_en),           // power up\n    .CLKHFEN(hfosc_en),           // enable\n    .CLKHF(clk_12m)\n  );\n\n  // Synchronous reset (optional external OR power-up). Keep it simple here.\n  logic reset;\n  // Small POR stretcher so downstream logic sees at least a few cycles of reset.\n  logic [7:0] por_cnt = '0;\n  always_ff @(posedge clk_12m) begin\n    if (por_cnt != 8'hFF) por_cnt &lt;= por_cnt + 1'b1;\n  end\n  assign reset = ext_reset | (por_cnt != 8'hFF);\n\n  // ---------------------------------------------------------------------------\n  // Keypad scanner (active-low matrix); parameterize for ~1 kHz frame rate\n  // With 12 MHz clk:\n  //   COL_DWELL_CYCLES = 3000  =&gt; per-column ~250 us; full frame ~1 ms\n  //   SETTLE_CYCLES    = 8     =&gt; small settle after column switch\n  // ---------------------------------------------------------------------------\n  logic        scan_any_key;\n  logic [3:0]  scan_code;\n\n  keypad_scanner #(\n    .COL_DWELL_CYCLES(3000),\n    .SETTLE_CYCLES(8)\n  ) u_scan (\n    .clk     (clk_12m),\n    .reset   (reset),\n    .cols    (cols),              // active-low driven here\n    .rows_in (rows),              // active-low read here\n    .any_key (scan_any_key),\n    .key_code(scan_code)\n  );\n\n  // ---------------------------------------------------------------------------\n  // One-shot registrar: single-cycle pulse on first stable press; ignores until\n  // full release. Set debounce to a few ms at 12 MHz (e.g., ~3 ms = 36,000).\n  // ---------------------------------------------------------------------------\n  logic        new_key_pulse;\n  logic [3:0]  new_key_code;\n  logic        busy;\n\n  keypad_one_shot #(\n    .DEBOUNCE_CYCLES(36_000)      // ~3 ms @ 12 MHz\n  ) u_reg (\n    .clk          (clk_12m),\n    .reset        (reset),\n    .any_key      (scan_any_key),\n    .key_code_in  (scan_code),\n    .new_key_pulse(new_key_pulse),\n    .key_code     (new_key_code),\n    .busy         (busy)\n  );\n\n  // ---------------------------------------------------------------------------\n  // Display registers: shift on new key only (older &lt;- most_recent; most_recent &lt;- new)\n  // ---------------------------------------------------------------------------\n  logic [3:0] digit_recent_q, digit_recent_n;\n  logic [3:0] digit_older_q,  digit_older_n;\n\n  always_comb begin\n    digit_recent_n = digit_recent_q;\n    digit_older_n  = digit_older_q;\n\n    if (new_key_pulse) begin\n      digit_older_n  = digit_recent_q;\n      digit_recent_n = new_key_code;\n    end\n  end\n\n  always_ff @(posedge clk_12m) begin\n    if (reset) begin\n      digit_recent_q &lt;= 4'h0;\n      digit_older_q  &lt;= 4'h0;\n    end else begin\n      digit_recent_q &lt;= digit_recent_n;\n      digit_older_q  &lt;= digit_older_n;\n    end\n  end\n\n  // ---------------------------------------------------------------------------\n  // Display multiplex: equal brightness, no flicker.\n  // Choose ~1 kHz per digit (2 kHz multiplex). @12 MHz: 12e6 / 2000 = 6000.\n  // We'll toggle 'mux_sel' every 3000 cycles → 2 kHz total (1 kHz per digit).\n  // ---------------------------------------------------------------------------\n  localparam int unsigned MUX_TOGGLE_CYCLES = 3000;   // 12e6 / (2*3000) = 2 kHz\n  localparam int CW_MUX = (MUX_TOGGLE_CYCLES &lt;= 1) ? 1 : $clog2(MUX_TOGGLE_CYCLES);\n\n  logic [CW_MUX-1:0] mux_cnt;\n  logic              mux_sel_q; // 0 = show LEFT(older), 1 = show RIGHT(recent)\n\n  always_ff @(posedge clk_12m) begin\n    if (reset) begin\n      mux_cnt  &lt;= '0;\n      mux_sel_q &lt;= 1'b0;\n    end else if (mux_cnt == MUX_TOGGLE_CYCLES-1) begin\n      mux_cnt  &lt;= '0;\n      mux_sel_q &lt;= ~mux_sel_q;\n    end else begin\n      mux_cnt &lt;= mux_cnt + 1'b1;\n    end\n  end\n\n  // Pick nibble for current digit; register seg pattern for glitch-free drive\n  logic [3:0] nibble_cur;\n  always_comb begin\n    // mux_sel_q = 0 -&gt; LEFT digit shows 'older'\n    // mux_sel_q = 1 -&gt; RIGHT digit shows 'recent'\n    nibble_cur = mux_sel_q ? digit_recent_q : digit_older_q;\n  end\n\n  // Segment encoder (assumed ACTIVE-HIGH output)\n  logic [6:0] seg_hi;\n  sevenSegment u_seg (\n    .hex(nibble_cur),\n    .seg(seg_hi)                   // a..g, ACTIVE-HIGH\n  );\n\n  // Register the segment outputs and digit enables for clean switching\n  logic [6:0] seg_hi_q;\n  logic [1:0] digit_en_hi_q;       // ACTIVE-HIGH enables (internal)\n\n  always_ff @(posedge clk_12m) begin\n    if (reset) begin\n      seg_hi_q      &lt;= 7'b0;\n      digit_en_hi_q &lt;= 2'b00;\n    end else begin\n      seg_hi_q      &lt;= seg_hi;\n      // INTERNAL: one-hot enable, HIGH = on (left,right)\n      digit_en_hi_q &lt;= (mux_sel_q) ? 2'b01  // right on, left off\n                                   : 2'b10; // left on, right off\n    end\n  end\n\n  // Board-level polarities (ACTIVE-LOW outputs)\n  assign seg_n   = ~seg_hi_q;\n  assign digit_n = ~digit_en_hi_q;\n\nendmodule\n\n\n\nI copied the SystemVerilog code provided by GPT5 into Lattice Radiant and attempted to synthesize it, which it did succesfully. Once again, I found myself impressed by the ability of the LLM to generate high quality SystemVerilog."
  },
  {
    "objectID": "posts/lab_1.html",
    "href": "posts/lab_1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs."
  },
  {
    "objectID": "posts/lab_1.html#introduction",
    "href": "posts/lab_1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs."
  },
  {
    "objectID": "posts/lab_1.html#soldering-the-development-board",
    "href": "posts/lab_1.html#soldering-the-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Soldering the Development Board",
    "text": "Soldering the Development Board\nWe were given a multitude of parts, both SMT and THT components. Soldering them to the E155 development board took approximately three hours, with the first thirty minutes spent attempting to solder the 5V regulator to the board. Figure 1 displays the completed development board.\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/lab_1.html#technical-documentation",
    "href": "posts/lab_1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 1 folder of my Github repository for E155.\n\nBlock Diagram\nFigure 2 (below) contains the block diagram used to design the combinational logic to drive the LEDs and 7-segment display.\n\n\n\n\nFigure 2\n\n\n\n\nLED Control\nTable 1 contains the truth table used to determine the state of the LEDs.\n\n\n\ns[0]\ns[1]\nled[0]\ns[2]\ns[3]\nled[1]\n\n\n\n\n0\n0\nOFF\n0\n0\nOFF\n\n\n1\n0\nON\n1\n0\nOFF\n\n\n0\n1\nON\n0\n1\nOFF\n\n\n1\n1\nOFF\n1\n1\nON\n\n\n\nBy inspection of figure 2, we see that led[0] is determined by s[0] XOR s[1], and led[1] is determined by s[2] AND s[3]. In order to blink led[2] at 2.4Hz, the HSOSC module was used to create a clock with a frequency of 24MHz. I then encoded a digitally controlled oscillator, using the formula f_LED = f_clk * p / 2^N. I chose values p = 430 and N = 32, theoretically producing an oscillator with a frequency of 2.403 Hz.\n\n\n7-Segment Display Control\nThe 7-segment display is controlled by a submodule that converts the input switches (s[3:0]) into a 7-bit output (s[6:0]). The submodule contains a case statement that converts each of the 16 possible 4-bit inputs into the corresponding values needed to illuminate the 7-segment display and create the corresponding hexadecimal number. Because the 7-segment display is common anode, the necessary pins are pulled to 0 to illuminate the necessary segments. For example, the input 4’h0 is converted to 7’b1000000. s[0] corresponds to segment A and s[6] corresponds to segment G of the 7-segment display. See figure 3 for the layout.\n\n\n\nSchematic\nI consulted the datasheet of the HDSP-511A display to determine which FPGA pins I would connect to the 7-segment display. The resultant schematic can be seen below.\n\n\n\nSchematic\n\n\nIn order to keep the current draw for each segment within recommended operating conditions, I used some Ohm’s law calculations. The datasheet of the HDSP-511A display recommends a maximum forward current of 15 mA. It also notes that the LEDs have a typical forward voltage of 2.0V. In order to calculate the current across the LED, I used Ohm’s law with \\(\\Delta V = 3.3 - 2.0\\) because the pins of the FPGA output 3.3V. Then, choosing 390 Ohm resistors (because they were the only ones available) results in a current of ~3.3mA across the LEDs, as seen below: \\[\\frac{3.3V-2.0V}{390 \\Omega} \\approx 3.3 mA\\] This current proved acceptable, as all segments of the display would light up with the same brightness, regardless of how many segments were illuminated."
  },
  {
    "objectID": "posts/lab_1.html#results-and-discussion",
    "href": "posts/lab_1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\nI created testbenches for each of the submodules (led_controller.sv and display_controller.sv) as well as a testbench for the top-level module. The images below show a screenshot of the QuestaSim simulations for my top-level module.  \n\nUsing an oscilloscope, I determined that led[2] was blinking at a frequency of 2.43Hz. The image below is a picture I took of the oscilloscope, where the frequency of the waveform can be seen in the bottom right."
  },
  {
    "objectID": "posts/lab_1.html#conclusion",
    "href": "posts/lab_1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nThe development board succesfully drove the 7-segment display and controlled the three LEDs as desired. This lab took 23 hours."
  },
  {
    "objectID": "posts/lab_1.html#ai-prototype",
    "href": "posts/lab_1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\nWhen I presented ChatGPT 5 with the task of using the Lattice UP5K FPGA’s internal high-speed oscillator to blink an LED at 2Hz, the SystemVerilog it provided synthesized, but Lattice Radiant was unable to place and route the design. It attempted to use the SB_HFOSC module, but provided an alternate solution in the initial Verilog. The code block was as follows:\n// Use SB_HFOSC (recommended for iCE40UP5K)\n    SB_HFOSC #(\n        .CLKHF_DIV(HF_DIV)\n    ) u_hfosc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)\n    );\n\n    // If your toolflow expects HSOSC instead, you can swap to:\n    // HSOSC u_hfosc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk_hf));\nOnce the project failed to place and route, I commented out the block using SB_HFOSC and uncommented the block using HSOSC. Making this change enabled Lattice Radiant to succesfully place and route the design. I was impressed by the quality of the output. GPT5 avoided overcommenting, which has been an issue in the past. However, the SystemVerilog provided still contained the right amount of comments for me to easily understand it.\nGPT5 used some syntax that was unfamiliar to me. It made use of localparam int unsigned to generate integers, which I hadn’t seen in SystemVerilog before. However, the new syntax it introduced was easy enough to understand. It wouldn’t surprise me the part of the prompt I gave GPT5 that read “Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg” contributed to the quality of the Verilog it generated. Moving forward, this serves as a good example of how effective prompting of LLMs can lead to much higher quality output."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 5: Interrupts\n\n\n\n\n\n\n\n\nOct 7, 2025\n\n\nDiego Weiss\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio\n\n\n\n\n\n\n\n\nOct 5, 2025\n\n\nDiego Weiss\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\n\n\n\n\n\n\nSep 17, 2025\n\n\nDiego Weiss\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\n\n\n\n\n\n\nSep 10, 2025\n\n\nDiego Weiss\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing\n\n\n\n\n\n\n\n\nAug 27, 2025\n\n\nDiego Weiss\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Diego Weiss, a Junior Engineering major at Harvey Mudd College. My main interests fall in the fields of robotics, controls, and embedded systems. When not at school, you can find me rock climbing, hiking, backcountry snowboarding, and playing soccer with my friends."
  },
  {
    "objectID": "posts/lab_2.html",
    "href": "posts/lab_2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "The goal of this lab was to implement a time multiplexing scheme on the UP5K FPGA to drive two seven-segment displays using only one set of I/0 pins. The full specs of this lab can be found on the lab 2 page of the Harvey Mudd E155 website."
  },
  {
    "objectID": "posts/lab_2.html#introduction",
    "href": "posts/lab_2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "The goal of this lab was to implement a time multiplexing scheme on the UP5K FPGA to drive two seven-segment displays using only one set of I/0 pins. The full specs of this lab can be found on the lab 2 page of the Harvey Mudd E155 website."
  },
  {
    "objectID": "posts/lab_2.html#technical-documentation",
    "href": "posts/lab_2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 2 folder of my Github repository for E155.\n\nBlock Diagram\nBefore I wrote any SystemVerilog, I created the following block diagram. This helped me understand the structure I believed my design should have prior to implementation. .\nI used a 16-bit clock divider to take the internal 24MHz clock to 366 Hz, which was used to determine the refresh rate of the 7-segment displays. This was determined to be an acceptable refresh rate by visual inspection, as the displays neither flickered nor had the LEDs bleed together.\n\n\nTestbenches\nThe waveforms and terminal outputs for display_logic.sv, display_controller.sv, and led_controller.sv are at the bottom of this section. display_logic.sv and led_controller.sv solely contained combinational logic. Each of these modules passed their respective testbenches. I wrote python scripts to generate test vectors for led_controller, display_controller, and lab2_dw. I also modified display_controller while testing it and while testing my top-level module. The only modification made was deactivating the clock divider in order to increase the speed of testing. The modifications can be seen below, along with the waveforms and terminal output for lab2_dw.\nlogic toggle;\n    logic [15:0] counter;\n    logic [3:0] sw;\n    \n    // Clock divider\n    //always_ff @(posedge clk) begin\n    //  if (reset) counter &lt;= 0;\n    //  else counter &lt;= counter + 1;\n    //end\n    \n    // assign toggle = counter[15];\n    assign toggle = clk;\n    \n    assign t1 = toggle;\n    assign t2 = ~toggle;\n    assign sw = toggle ? s2 : s1;\n    display_logic DISPLAY(.s(sw), .seg(seg));\n\n\n\nTop-Level Module Waveforms\n\n\n\n\n\nTop-Level Module Output\n\n\n\n\n\n\n\n\nWaveform Gallery\n\n\n\n\n\n\n\n\nLED Controller Waveforms\n\n\n\n\n\nLED Controller Testbench Output\n\n\n\n\n\nDisplay Logic Waveforms\n\n\n\n\n\nDisplay Logic Testbench Output\n\n\n\n\n\nDisplay Controller Waveforms\n\n\n\n\n\nDisplay Controller Waveforms\n\n\n\n\n\n\n\nCircuit Design\nIn order to physically implement the desired design, I designed the following circuits using pins on the iCE40 FPGA. In order to make the switches operate properly, the internal 100k Ohm pull-up resistors on the iCE40 FPGA were enabled.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Circuit Schematics\n\n\n\nTo select the resistors placed between the FPGA pins and the 2N3906 transistor, the datasheet for the ice40 FPGA was consulted. Sections 4.16 and 4.17 describe the electrical characteristics of the I/O pins. For a pin outputting 3.3V, the maximum current it can drive is 8 mA. The datasheet for the 2N3906 transistor states that the base-emitter saturation voltage is in the range of 0.65-0.75. This means that there is a voltage drop of approximately 0.75V across the base-emitter junction. Since VE = 3.3V, the base has a voltage of approximately 2.55V. Using Ohm’s Law, we see that a 2200 Ohm resistor results in a current draw of ~1.16mA to each FPGA pin.\nIn order to select the resistor values between the FPGAs and the LEDs on the 7-segment display, I consulted the datasheet for the HDSP-521A 7-segment display, which gives the forward voltage per segment as 2.0V. The LEDs are driven by the collector of the 2N3906 resistor when the corresponding pin is pulled low. I measured the voltage out of the transistor to be ~2.95V while debugging my toggle signals. Subtracting the forward voltage from the supply voltage, we see 0.95V across the resistor. A resistor value of 180 Ohms results in a current of ~5.3 mA is going into the LED segments."
  },
  {
    "objectID": "posts/lab_2.html#conclusion",
    "href": "posts/lab_2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThe design meets all the requirements for the lab. I spent 15 hours working on this lab."
  },
  {
    "objectID": "posts/lab_2.html#ai-prototype",
    "href": "posts/lab_2.html#ai-prototype",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\nI first provided ChatGPT 5 with the following instruction: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” It produced the following code:\n\n\n\n\n\n\nCode\n\n\n\n\n\n//------------------------------------------------------------------------------\n// Two-digit time-multiplexed seven-seg driver (common-anode, active-low)\n// Reuses ONE decoder to drive TWO [6:0] segment buses.\n//\n// seg*_n is {g,f,e,d,c,b,a} with 0 = segment ON (active-low), 1 = OFF.\n//\n// Parametrize CLK_HZ and REFRESH_HZ to suit your board.\n// REFRESH_HZ is the per-digit toggle rate (each digit is refreshed at REFRESH_HZ/2).\n//------------------------------------------------------------------------------\n\nmodule sevenseg2_mux #(\n    parameter int unsigned CLK_HZ      = 50_000_000,   // input clock in Hz\n    parameter int unsigned REFRESH_HZ  = 1_000         // digit toggle rate in Hz\n)(\n    input  logic        clk,\n    input  logic        rst_n,\n\n    // two independent 4-bit values to display (hex)\n    input  logic [3:0]  in0,\n    input  logic [3:0]  in1,\n\n    // two 7-bit segment buses (active-low), order = {g,f,e,d,c,b,a}\n    output logic [6:0]  seg0_n,\n    output logic [6:0]  seg1_n\n);\n\n    // ------------------------\n    // Clock divider for refresh\n    // ------------------------\n    localparam int unsigned DIV = (CLK_HZ / REFRESH_HZ);\n    localparam int unsigned CW  = (DIV &gt; 1) ? $clog2(DIV) : 1;\n\n    logic [CW-1:0] divcnt;\n    logic          tick;     // 1-cycle strobe at REFRESH_HZ\n    logic          sel;      // which digit is currently active: 0 -&gt; digit0, 1 -&gt; digit1\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            divcnt &lt;= '0;\n            tick   &lt;= 1'b0;\n        end else begin\n            if (divcnt == DIV-1) begin\n                divcnt &lt;= '0;\n                tick   &lt;= 1'b1;\n            end else begin\n                divcnt &lt;= divcnt + 1'b1;\n                tick   &lt;= 1'b0;\n            end\n        end\n    end\n\n    // toggle active digit on each tick\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sel &lt;= 1'b0;\n        end else if (tick) begin\n            sel &lt;= ~sel;\n        end\n    end\n\n    // ------------------------\n    // Single shared decoder\n    // ------------------------\n    logic [3:0]  cur_nibble;\n    logic [6:0]  seg_dec_n;  // active-low segments for current nibble\n\n    always_comb cur_nibble = sel ? in1 : in0;\n\n    // hex to seven-seg (common-anode, active-low), {g,f,e,d,c,b,a}\n    function automatic logic [6:0] hex_to_7seg_n(input logic [3:0] x);\n        unique case (x)\n            4'h0: hex_to_7seg_n = 7'b1000000;\n            4'h1: hex_to_7seg_n = 7'b1111001;\n            4'h2: hex_to_7seg_n = 7'b0100100;\n            4'h3: hex_to_7seg_n = 7'b0110000;\n            4'h4: hex_to_7seg_n = 7'b0011001;\n            4'h5: hex_to_7seg_n = 7'b0010010;\n            4'h6: hex_to_7seg_n = 7'b0000010;\n            4'h7: hex_to_7seg_n = 7'b1111000;\n            4'h8: hex_to_7seg_n = 7'b0000000;\n            4'h9: hex_to_7seg_n = 7'b0010000;\n            4'hA: hex_to_7seg_n = 7'b0001000; // A\n            4'hB: hex_to_7seg_n = 7'b0000011; // b\n            4'hC: hex_to_7seg_n = 7'b1000110; // C\n            4'hD: hex_to_7seg_n = 7'b0100001; // d\n            4'hE: hex_to_7seg_n = 7'b0000110; // E\n            4'hF: hex_to_7seg_n = 7'b0001110; // F\n            default: hex_to_7seg_n = 7'b1111111; // all off\n        endcase\n    endfunction\n\n    always_comb seg_dec_n = hex_to_7seg_n(cur_nibble);\n\n    // ------------------------\n    // Drive both outputs\n    // Only the \"selected\" digit shows the decoded pattern;\n    // the other is forced off (all 1s for active-low).\n    // ------------------------\n    localparam logic [6:0] OFF = 7'b111_1111;\n\n    always_comb begin\n        seg0_n = sel ? OFF       : seg_dec_n;\n        seg1_n = sel ? seg_dec_n : OFF;\n    end\n\nendmodule\n\n\n\nThe SystemVerilog ChatGPT provided synthesized on the first attempt. It was interesting to see the LLM use structures like functions, which I didn’t know existed in SystemVerilog. I was also interested to see that it created two logic signals for the separate displays.\nI next provided GPT-5 with the following instructions: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” GPT-5 produced two separate SystemVerilog modules, which can be seen below.\n\n\n\n\n\n\nCode\n\n\n\n\n\n// Author: ChatGPT\n// Date: 2025-09-10\n// Description:\n//   Time-multiplex a *single* seven-segment decoder (display_controller.sv provided)\n//   to drive *two* common-anode seven-segment displays using two 4-bit inputs.\n//   The decoder output is active-low (0 = segment ON), matching the provided decoder.\n//\n//   The module uses the on-chip high-speed oscillator (HSOSC) like in lab1_dw.sv.\n//   Only one display is driven at a time; the other is forced OFF (all 1's).\n//   A fast refresh counter flips which display is active, giving the appearance\n//   that both are lit continuously (persistence of vision).\n//\n//   Notes:\n//   - reset is treated as active-low to match the style in led_controller.sv.\n//   - REFRESH_BITS controls the per-digit refresh rate. With a ~24 MHz clock and\n//     REFRESH_BITS=14, each digit updates at ~732 Hz (overall toggle ~1.46 kHz).\n\nmodule sevenseg_dual_mux (\n    input  logic        reset,      // Active-low reset (0 = reset)\n    input  logic [3:0]  a,          // 4-bit value for Display A\n    input  logic [3:0]  b,          // 4-bit value for Display B\n    output logic [6:0]  seg_a,      // Segment lines for Display A (active-low)\n    output logic [6:0]  seg_b       // Segment lines for Display B (active-low)\n);\n\n    // -------------------------------------------------------------------------\n    // Internal clock from on-chip high-speed oscillator (same primitive as lab1)\n    // -------------------------------------------------------------------------\n    logic int_osc;\n    // Initialize high-speed oscillator; same parameters as lab1_dw.sv\n    HSOSC #(.CLKHF_DIV(2'b01)) \n        hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n\n    // -------------------------------------------------------------------------\n    // Refresh logic\n    // -------------------------------------------------------------------------\n    parameter int REFRESH_BITS = 14;  // Increase for slower toggle, decrease for faster\n    logic [REFRESH_BITS-1:0] refresh_ctr /* synthesis preserve */;\n    logic sel_digit;  // 0 =&gt; drive A, 1 =&gt; drive B\n\n    always_ff @(posedge int_osc) begin\n        if (reset == 1'b0) begin\n            refresh_ctr &lt;= '0;\n        end else begin\n            refresh_ctr &lt;= refresh_ctr + 1'b1;\n        end\n    end\n    assign sel_digit = refresh_ctr[REFRESH_BITS-1];\n\n    // -------------------------------------------------------------------------\n    // Single decoder instance (provided module: display_controller)\n    // -------------------------------------------------------------------------\n    logic [3:0] s_mux;\n    logic [6:0] seg_decoded;\n\n    // Choose which 4-bit input the decoder sees at this moment\n    assign s_mux = (sel_digit == 1'b0) ? a : b;\n\n    // One (and only one) decoder instance\n    display_controller DEC (\n        .s   (s_mux),\n        .seg (seg_decoded)\n    );\n\n    // Drive only the selected display; force the other OFF (all 1's for common anode)\n    always_comb begin\n        if (sel_digit == 1'b0) begin\n            seg_a = seg_decoded;        // Active display gets decoded segments\n            seg_b = 7'b111_1111;        // Other display off\n        end else begin\n            seg_a = 7'b111_1111;\n            seg_b = seg_decoded;\n        end\n    end\n\nendmodule\n\n// Example top-level that uses sevenseg_dual_mux with two 4-bit switch groups.\n// Replace I/O names as needed for your constraints file.\nmodule lab1_dual_top (\n    input  logic        reset,      // Active-low reset\n    input  logic [7:0]  sw,         // Eight switches: sw[3:0] -&gt; Display A, sw[7:4] -&gt; Display B\n    output logic [6:0]  seg_a,      // Seven-seg A (a..g), active-low\n    output logic [6:0]  seg_b       // Seven-seg B (a..g), active-low\n);\n\n    sevenseg_dual_mux UUT (\n        .reset (reset),\n        .a     (sw[3:0]),\n        .b     (sw[7:4]),\n        .seg_a (seg_a),\n        .seg_b (seg_b)\n    );\n\nendmodule\n\n\n\nThe provided SystemVerilog synthesized upon the inclusion of display_controller.sv from lab 1 as a source file. However, GPT-5 did not provide the instruction to do that. Something I don’t like about LLMs is that they overcomment their code, which makes it more difficult to read. However, I was impressed that the LLM managed to provide SystemVerilog that synthesized with little effort."
  },
  {
    "objectID": "posts/lab_4.html",
    "href": "posts/lab_4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "The goal of this lab was to use our STM32 MCUs to play music by toggling a GPIO pin using timers at a specific frequency for specific durations. From a technical standpoint, the goal of this lab was to gain confidence reading the datasheet and writing device drivers."
  },
  {
    "objectID": "posts/lab_4.html#introduction",
    "href": "posts/lab_4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "The goal of this lab was to use our STM32 MCUs to play music by toggling a GPIO pin using timers at a specific frequency for specific durations. From a technical standpoint, the goal of this lab was to gain confidence reading the datasheet and writing device drivers."
  },
  {
    "objectID": "posts/lab_4.html#technical-documentation",
    "href": "posts/lab_4.html#technical-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nAs always, all the code for this lab can be found in the lab 4 folder of my Github repository for E155.\n\nCircuitry\nI consulted the datasheet of the LM386N-4 audio op-amp to design my circuit. It features a potentiometer for volume control, and the LM386N-4 ensures the current draw on the microcontroller stays at acceptable levels.\n\n\n\nCircuit\n\n\n\n\nTiming\nI used the Timer 15 and Timer 16 registers to output a square wave from the microcontroller. By configuring the timers in PWM mode and connecting them to a GPIO Pin, I was able to use the timers to drive a square wave output. I used the phase-locked loop to clock the microcontroller at 80Mhz. I used a prescaler value of 999 for timer 16. By configuring my auto-reload value to be 16 bits, the minimum and maximum frequency supported by my clock can be determined by setting the auto-reload value to 0 and 65536 respectively. I used the following formulas to do my calculations: \\[f_{cnt} = \\frac{f_{clk}}{PSC + 1}\\] \\[\\frac{1}{f_{sound}} = \\frac{1}{f_{cnt}} \\cdot \\text{cycles}\\] \\[\\text{cycles} = \\frac{f_{clk}}{f_{sound} \\cdot (PSC + 1)}\\] \\[f_{sound} = \\frac{f_{clk}}{\\text{cycles} \\cdot (PSC + 1)}\\]\nWith these formulas, the initial clock value of 80 Mhz, and the range for the auto-reload value of 0 to 65536, a minimum frequency of 1.22Hz (when the auto-reload is 65536) and a maximum frequency of 80 kHz (when the auto-reload is 0) can be determined. To ensure that individual pitches are accurate to within 1% across the frequency range of 220-1000 Hz, I did some calculations in google sheets, which can be seen below.\n\n\n\nFrequency Calculations\n\n\nIn order to determine the minimum and maximum delay, I performed similar calculations. I used a prescaler of 1999 and configured timer 15 for my delays. The maximum duration produced given this prescaler value and the 80Mhz system clock should be 1.64 seconds (when the auto-reload value is 65535). The minimum duration produced given this prescaler value and the 80Mhz system clock should be 0.025 milliseconds (when the auto-reload value is 0)."
  },
  {
    "objectID": "posts/lab_4.html#conclusion",
    "href": "posts/lab_4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design fulfilled all the requirements, playing both Fur Elise and hot cross buns. I spent 9 hours on this lab."
  },
  {
    "objectID": "posts/lab_4.html#ai-prototype",
    "href": "posts/lab_4.html#ai-prototype",
    "title": "Lab 4: Digital Audio",
    "section": "AI Prototype",
    "text": "AI Prototype\nI began by giving ChatGPT 5 the following prompt:\n\n\n\n\n\n\nNote\n\n\n\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\n\nThe full chat output produced by GPT5 can be seen at this link. Notably, GPT5 gave me formulas for determining PWM frequency and OC toggle frequency. It also gave me instructions for picking PSC/ARR, and told me to fix PSC and vary ARR across my range. It gave me instructions to configure the AHB2ENR and APB1ENR1 registers for the RCC, the MODER and AFR[0/1] reigsters for GPIO, and the CR1, PSC, and ARR registers for TIMx (x being whichever TIM I chose). These were not the registers I used to configure the RCC, and I didn’t touch the AFR[0/1] registers, but the rest of the advice was sound. It also gave me what amounts to pseudocode for the main method, which could be useful."
  }
]