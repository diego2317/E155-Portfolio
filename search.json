[
  {
    "objectID": "posts/lab_3.html",
    "href": "posts/lab_3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "The goal of this lab was to learn how to use an FPGA to scan inputs from a keypad, and then output the two most recent inputs on the multiplexed 7-segment display from lab 2. The crux of this lab was ensuring I followed synchronous design principles, as well as designing an FSM that took switch debouncing into account. The lab 3 page of the E155 website has more information about the lab."
  },
  {
    "objectID": "posts/lab_3.html#introduction",
    "href": "posts/lab_3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "The goal of this lab was to learn how to use an FPGA to scan inputs from a keypad, and then output the two most recent inputs on the multiplexed 7-segment display from lab 2. The crux of this lab was ensuring I followed synchronous design principles, as well as designing an FSM that took switch debouncing into account. The lab 3 page of the E155 website has more information about the lab."
  },
  {
    "objectID": "posts/lab_3.html#technical-documentation",
    "href": "posts/lab_3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 3 folder of my Github repository for E155.\n\nCircuit Design\nUnlike previous labs, I began this one by designing my circuits. I made this decision because I felt like doing so would prove beneficial in going through the rest of the lab. The circuit I designed can be seen below. It features two 2N3906 PNP transistors being used to power the 7-segment display. The rational behind my design choices for the circuitry involving the transistors and the 7-segment display can be found in my writeup for lab 2.\nTo design my keypad scanning scheme, I made the initial decision that I would drive the rows of the keypad as outputs and read the columns as inputs. I chose to drive my rows high, which meant that to “select” a row to read I would drive it low (keeping the rest of the rows high) and read the columns. If I pressed a key in the row I was reading, it would short that row and column together, which means that a key press is represented by a low voltage level instead of a high one. I used the internal 100 kOhm resistors on the FPGA to enable this behavior. My pin assignments and general wiring are displayed in the circuits below.\n\n\n\nCircuit\n\n\n\n\nFSM\nThe next step I took was developing my FSM. Initially, I planned on utilizing two completely separate FSMs, one for scanning the rows and one for debouncing once a key was pressed. However, I ended up combining my initial two ideas into one big FSM, which can be seen below. In the FSM, a 1 represents a key press being detected and a 0 represents no keys being pressed. I used a counter to keep track of how many clock cycles had passed, with the counter incrementing each clock cycle. In order to deal with the delay from the synchronizer, the FSM stays in the BUFFER states for two clock cycles, which is how long it takes my synchronizer to synchronize the inputs. Whenever the FSM enters any of the ROW, PULSE, or WAIT states, the counter is reset to 0. To solve debouncing, I have the counter increment by 1 per clock cycle if it’s in a DEBOUNCE state. Once counter has incremented 16 times (counter = 15), the transition can be made to the PULSE state if the key is still pressed. In the PULSE state, the FSM sends a signal called PRESS to my next-state logic. PRESS serves as a select signal to determine whether or not a new key has been pressed, which then enables the updating of the 7-segment display. My full FSM can be seen below, as well as its associated state transition table.\n\n\n\nFSM\n\n\n\n\n\nTruth Table\n\n\n\n\nBlock Diagram + Verilog Design\nImplementing this design required 9 separate SystemVerilog modules, including the top-level module and the built-in HSOSC module for clock generation. After initializing a clock to 24 MHz using the HSOSC module, I divided the clock down to 1.2 kHz using a module of my own design. This new “slow clock” then became the system-level clock. The modules for controlling the 7-segment display were taken from lab 2, although the multiplexer module was modified to divide the clock by a factor of two instead of 2^15. This meant that the 7-segment display has a refresh rate of 600Hz, which is sufficient to not notice flickering. I chose a 1.2kHz clock so that once the FSM went through the 16 debounce clock cycles, there would be no risk that the switch was bouncing. This also meant that a button would need to be pressed for approximately 13 ms to be recognized as pressed, which I felt was reasonable. The block diagram for my system can be seen below.\n\n\n\nBlock Diagram\n\n\n\n\nWaveforms\nBefore testing my physical system, I wrote testbenches for all of my modules (except for the 7-segment display logic module, which has been the same since lab 1). This meant that once it was time to build my physical system, I was able to get it working quickly. The waveforms and testbench output for my top-level module can be seen below. The Waveform Gallery can be expanded to view the waveforms and testbench output for the rest of my modules.\n\n\n\nTop Level Module Testbench Waveforms\n\n\n\n\n\nTop Level Module Testbench Output\n\n\n\n\n\n\n\n\nWaveform Gallery\n\n\n\n\n\n\n\n\nKeypad Decoder Testbench Waveforms\n\n\n\n\n\nKeypad Decoder Testbench Output\n\n\n\n\n\nKeypad Input Testbench Waveforms\n\n\n\n\n\nKeypad Input Testbench Output\n\n\n\n\n\nKeypad Reader Testbench Waveforms\n\n\n\n\n\nKeypad Reader Testbench Output\n\n\n\n\n\nSeven Segment Controller Testbench Waveforms\n\n\n\n\n\nSeven Segment Controller Testbench Output\n\n\n\n\n\nSynchronizer Testbench Waveforms\n\n\n\n\n\nSynchronizer Testbench Output\n\n\n\n\n\n\n\nConclusion\nThe design meets all the requirements. I spent somewhere between 25 and 30 hours on this lab."
  },
  {
    "objectID": "posts/lab_1.html",
    "href": "posts/lab_1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs."
  },
  {
    "objectID": "posts/lab_1.html#introduction",
    "href": "posts/lab_1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs."
  },
  {
    "objectID": "posts/lab_1.html#soldering-the-development-board",
    "href": "posts/lab_1.html#soldering-the-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Soldering the Development Board",
    "text": "Soldering the Development Board\nWe were given a multitude of parts, both SMT and THT components. Soldering them to the E155 development board took approximately three hours, with the first thirty minutes spent attempting to solder the 5V regulator to the board. Figure 1 displays the completed development board.\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/lab_1.html#technical-documentation",
    "href": "posts/lab_1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 1 folder of my Github repository for E155.\n\nBlock Diagram\nFigure 2 (below) contains the block diagram used to design the combinational logic to drive the LEDs and 7-segment display.\n\n\n\n\nFigure 2\n\n\n\n\nLED Control\nTable 1 contains the truth table used to determine the state of the LEDs.\n\n\n\ns[0]\ns[1]\nled[0]\ns[2]\ns[3]\nled[1]\n\n\n\n\n0\n0\nOFF\n0\n0\nOFF\n\n\n1\n0\nON\n1\n0\nOFF\n\n\n0\n1\nON\n0\n1\nOFF\n\n\n1\n1\nOFF\n1\n1\nON\n\n\n\nBy inspection of figure 2, we see that led[0] is determined by s[0] XOR s[1], and led[1] is determined by s[2] AND s[3]. In order to blink led[2] at 2.4Hz, the HSOSC module was used to create a clock with a frequency of 24MHz. I then encoded a digitally controlled oscillator, using the formula f_LED = f_clk * p / 2^N. I chose values p = 430 and N = 32, theoretically producing an oscillator with a frequency of 2.403 Hz.\n\n\n7-Segment Display Control\nThe 7-segment display is controlled by a submodule that converts the input switches (s[3:0]) into a 7-bit output (s[6:0]). The submodule contains a case statement that converts each of the 16 possible 4-bit inputs into the corresponding values needed to illuminate the 7-segment display and create the corresponding hexadecimal number. Because the 7-segment display is common anode, the necessary pins are pulled to 0 to illuminate the necessary segments. For example, the input 4’h0 is converted to 7’b1000000. s[0] corresponds to segment A and s[6] corresponds to segment G of the 7-segment display. See figure 3 for the layout.\n\n\n\nSchematic\nI consulted the datasheet of the HDSP-511A display to determine which FPGA pins I would connect to the 7-segment display. The resultant schematic can be seen below.\n\n\n\nSchematic\n\n\nIn order to keep the current draw for each segment within recommended operating conditions, I used some Ohm’s law calculations. The datasheet of the HDSP-511A display recommends a maximum forward current of 15 mA. Since the FPGA supplies 3.3V, I chose 390 Ohm resistors, which result in a current of ~8.5mA."
  },
  {
    "objectID": "posts/lab_1.html#results-and-discussion",
    "href": "posts/lab_1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\nI created testbenches for each of the submodules (led_controller.sv and display_controller.sv) as well as a testbench for the top-level module. The images below show a screenshot of the QuestaSim simulations for my top-level module.  \n\nUsing an oscilloscope, I determined that led[2] was blinking at a frequency of 2.43Hz. The image below is a picture I took of the oscilloscope, where the frequency of the waveform can be seen in the bottom right."
  },
  {
    "objectID": "posts/lab_1.html#conclusion",
    "href": "posts/lab_1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nThe development board succesfully drove the 7-segment display and controlled the three LEDs as desired. This lab took 23 hours."
  },
  {
    "objectID": "posts/lab_1.html#ai-prototype",
    "href": "posts/lab_1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\nWhen I presented ChatGPT 5 with the task of using the Lattice UP5K FPGA’s internal high-speed oscillator to blink an LED at 2Hz, the SystemVerilog it provided synthesized, but Lattice Radiant was unable to place and route the design. It attempted to use the SB_HFOSC module, but provided an alternate solution in the initial Verilog. The code block was as follows:\n// Use SB_HFOSC (recommended for iCE40UP5K)\n    SB_HFOSC #(\n        .CLKHF_DIV(HF_DIV)\n    ) u_hfosc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)\n    );\n\n    // If your toolflow expects HSOSC instead, you can swap to:\n    // HSOSC u_hfosc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk_hf));\nOnce the project failed to place and route, I commented out the block using SB_HFOSC and uncommented the block using HSOSC. Making this change enabled Lattice Radiant to succesfully place and route the design. I was impressed by the quality of the output. GPT5 avoided overcommenting, which has been an issue in the past. However, the SystemVerilog provided still contained the right amount of comments for me to easily understand it.\nGPT5 used some syntax that was unfamiliar to me. It made use of localparam int unsigned to generate integers, which I hadn’t seen in SystemVerilog before. However, the new syntax it introduced was easy enough to understand. It wouldn’t surprise me the part of the prompt I gave GPT5 that read “Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg” contributed to the quality of the Verilog it generated. Moving forward, this serves as a good example of how effective prompting of LLMs can lead to much higher quality output."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 3: Keypad Scanner\n\n\n\n\n\n\n\n\nSep 17, 2025\n\n\nDiego Weiss\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\n\n\n\n\n\n\nSep 10, 2025\n\n\nDiego Weiss\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing\n\n\n\n\n\n\n\n\nAug 27, 2025\n\n\nDiego Weiss\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Diego Weiss, a Junior Engineering major at Harvey Mudd College. My main interests fall in the fields of robotics, controls, and embedded systems. When not at school, you can find me rock climbing, hiking, backcountry snowboarding, and playing soccer with my friends."
  },
  {
    "objectID": "posts/lab_2.html",
    "href": "posts/lab_2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "The goal of this lab was to implement a time multiplexing scheme on the UP5K FPGA to drive two seven-segment displays using only one set of I/0 pins. The full specs of this lab can be found on the lab 2 page of the Harvey Mudd E155 website."
  },
  {
    "objectID": "posts/lab_2.html#introduction",
    "href": "posts/lab_2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "The goal of this lab was to implement a time multiplexing scheme on the UP5K FPGA to drive two seven-segment displays using only one set of I/0 pins. The full specs of this lab can be found on the lab 2 page of the Harvey Mudd E155 website."
  },
  {
    "objectID": "posts/lab_2.html#technical-documentation",
    "href": "posts/lab_2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 2 folder of my Github repository for E155.\n\nBlock Diagram\nBefore I wrote any SystemVerilog, I created the following block diagram. This helped me understand the structure I believed my design should have prior to implementation. .\nI used a 16-bit clock divider to take the internal 24MHz clock to 366 Hz, which was used to determine the refresh rate of the 7-segment displays. This was determined to be an acceptable refresh rate by visual inspection, as the displays neither flickered nor had the LEDs bleed together.\n\n\nTestbenches\nThe waveforms and terminal outputs for display_logic.sv, display_controller.sv, and led_controller.sv are at the bottom of this section. display_logic.sv and led_controller.sv solely contained combinational logic. Each of these modules passed their respective testbenches. I wrote python scripts to generate test vectors for led_controller, display_controller, and lab2_dw. I also modified display_controller while testing it and while testing my top-level module. The only modification made was deactivating the clock divider in order to increase the speed of testing. The modifications can be seen below, along with the waveforms and terminal output for lab2_dw.\nlogic toggle;\n    logic [15:0] counter;\n    logic [3:0] sw;\n    \n    // Clock divider\n    //always_ff @(posedge clk) begin\n    //  if (reset) counter &lt;= 0;\n    //  else counter &lt;= counter + 1;\n    //end\n    \n    // assign toggle = counter[15];\n    assign toggle = clk;\n    \n    assign t1 = toggle;\n    assign t2 = ~toggle;\n    assign sw = toggle ? s2 : s1;\n    display_logic DISPLAY(.s(sw), .seg(seg));\n\n\n\nTop-Level Module Waveforms\n\n\n\n\n\nTop-Level Module Output\n\n\n\n\n\n\n\n\nWaveform Gallery\n\n\n\n\n\n\n\n\nLED Controller Waveforms\n\n\n\n\n\nLED Controller Testbench Output\n\n\n\n\n\nDisplay Logic Waveforms\n\n\n\n\n\nDisplay Logic Testbench Output\n\n\n\n\n\nDisplay Controller Waveforms\n\n\n\n\n\nDisplay Controller Waveforms\n\n\n\n\n\n\n\nCircuit Design\nIn order to physically implement the desired design, I designed the following circuits using pins on the iCE40 FPGA. In order to make the switches operate properly, the internal 100k Ohm pull-up resistors on the iCE40 FPGA were enabled.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Circuit Schematics\n\n\n\nTo select the resistors placed between the FPGA pins and the 2N3906 transistor, the datasheet for the ice40 FPGA was consulted. Sections 4.16 and 4.17 describe the electrical characteristics of the I/O pins. For a pin outputting 3.3V, the maximum current it can drive is 8 mA. The datasheet for the 2N3906 transistor states that the base-emitter saturation voltage is in the range of 0.65-0.75. This means that there is a voltage drop of approximately 0.75V across the base-emitter junction. Since VE = 3.3V, the base has a voltage of approximately 2.55V. Using Ohm’s Law, we see that a 2200 Ohm resistor results in a current draw of ~1.16mA to each FPGA pin.\nIn order to select the resistor values between the FPGAs and the LEDs on the 7-segment display, I consulted the datasheet for the HDSP-521A 7-segment display, which gives the forward voltage per segment as 2.0V. The LEDs are driven by the collector of the 2N3906 resistor when the corresponding pin is pulled low. I measured the voltage out of the transistor to be ~2.95V while debugging my toggle signals. Subtracting the forward voltage from the supply voltage, we see 0.95V across the resistor. A resistor value of 180 Ohms results in a current of ~5.3 mA is going into the LED segments."
  },
  {
    "objectID": "posts/lab_2.html#conclusion",
    "href": "posts/lab_2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThe design meets all the requirements for the lab. I spent 15 hours working on this lab."
  },
  {
    "objectID": "posts/lab_2.html#ai-prototype",
    "href": "posts/lab_2.html#ai-prototype",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\nI first provided ChatGPT 5 with the following instruction: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” It produced the following code:\n\n\n\n\n\n\nCode\n\n\n\n\n\n//------------------------------------------------------------------------------\n// Two-digit time-multiplexed seven-seg driver (common-anode, active-low)\n// Reuses ONE decoder to drive TWO [6:0] segment buses.\n//\n// seg*_n is {g,f,e,d,c,b,a} with 0 = segment ON (active-low), 1 = OFF.\n//\n// Parametrize CLK_HZ and REFRESH_HZ to suit your board.\n// REFRESH_HZ is the per-digit toggle rate (each digit is refreshed at REFRESH_HZ/2).\n//------------------------------------------------------------------------------\n\nmodule sevenseg2_mux #(\n    parameter int unsigned CLK_HZ      = 50_000_000,   // input clock in Hz\n    parameter int unsigned REFRESH_HZ  = 1_000         // digit toggle rate in Hz\n)(\n    input  logic        clk,\n    input  logic        rst_n,\n\n    // two independent 4-bit values to display (hex)\n    input  logic [3:0]  in0,\n    input  logic [3:0]  in1,\n\n    // two 7-bit segment buses (active-low), order = {g,f,e,d,c,b,a}\n    output logic [6:0]  seg0_n,\n    output logic [6:0]  seg1_n\n);\n\n    // ------------------------\n    // Clock divider for refresh\n    // ------------------------\n    localparam int unsigned DIV = (CLK_HZ / REFRESH_HZ);\n    localparam int unsigned CW  = (DIV &gt; 1) ? $clog2(DIV) : 1;\n\n    logic [CW-1:0] divcnt;\n    logic          tick;     // 1-cycle strobe at REFRESH_HZ\n    logic          sel;      // which digit is currently active: 0 -&gt; digit0, 1 -&gt; digit1\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            divcnt &lt;= '0;\n            tick   &lt;= 1'b0;\n        end else begin\n            if (divcnt == DIV-1) begin\n                divcnt &lt;= '0;\n                tick   &lt;= 1'b1;\n            end else begin\n                divcnt &lt;= divcnt + 1'b1;\n                tick   &lt;= 1'b0;\n            end\n        end\n    end\n\n    // toggle active digit on each tick\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sel &lt;= 1'b0;\n        end else if (tick) begin\n            sel &lt;= ~sel;\n        end\n    end\n\n    // ------------------------\n    // Single shared decoder\n    // ------------------------\n    logic [3:0]  cur_nibble;\n    logic [6:0]  seg_dec_n;  // active-low segments for current nibble\n\n    always_comb cur_nibble = sel ? in1 : in0;\n\n    // hex to seven-seg (common-anode, active-low), {g,f,e,d,c,b,a}\n    function automatic logic [6:0] hex_to_7seg_n(input logic [3:0] x);\n        unique case (x)\n            4'h0: hex_to_7seg_n = 7'b1000000;\n            4'h1: hex_to_7seg_n = 7'b1111001;\n            4'h2: hex_to_7seg_n = 7'b0100100;\n            4'h3: hex_to_7seg_n = 7'b0110000;\n            4'h4: hex_to_7seg_n = 7'b0011001;\n            4'h5: hex_to_7seg_n = 7'b0010010;\n            4'h6: hex_to_7seg_n = 7'b0000010;\n            4'h7: hex_to_7seg_n = 7'b1111000;\n            4'h8: hex_to_7seg_n = 7'b0000000;\n            4'h9: hex_to_7seg_n = 7'b0010000;\n            4'hA: hex_to_7seg_n = 7'b0001000; // A\n            4'hB: hex_to_7seg_n = 7'b0000011; // b\n            4'hC: hex_to_7seg_n = 7'b1000110; // C\n            4'hD: hex_to_7seg_n = 7'b0100001; // d\n            4'hE: hex_to_7seg_n = 7'b0000110; // E\n            4'hF: hex_to_7seg_n = 7'b0001110; // F\n            default: hex_to_7seg_n = 7'b1111111; // all off\n        endcase\n    endfunction\n\n    always_comb seg_dec_n = hex_to_7seg_n(cur_nibble);\n\n    // ------------------------\n    // Drive both outputs\n    // Only the \"selected\" digit shows the decoded pattern;\n    // the other is forced off (all 1s for active-low).\n    // ------------------------\n    localparam logic [6:0] OFF = 7'b111_1111;\n\n    always_comb begin\n        seg0_n = sel ? OFF       : seg_dec_n;\n        seg1_n = sel ? seg_dec_n : OFF;\n    end\n\nendmodule\n\n\n\nThe SystemVerilog ChatGPT provided synthesized on the first attempt. It was interesting to see the LLM use structures like functions, which I didn’t know existed in SystemVerilog. I was also interested to see that it created two logic signals for the separate displays.\nI next provided GPT-5 with the following instructions: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” GPT-5 produced two separate SystemVerilog modules, which can be seen below.\n\n\n\n\n\n\nCode\n\n\n\n\n\n// Author: ChatGPT\n// Date: 2025-09-10\n// Description:\n//   Time-multiplex a *single* seven-segment decoder (display_controller.sv provided)\n//   to drive *two* common-anode seven-segment displays using two 4-bit inputs.\n//   The decoder output is active-low (0 = segment ON), matching the provided decoder.\n//\n//   The module uses the on-chip high-speed oscillator (HSOSC) like in lab1_dw.sv.\n//   Only one display is driven at a time; the other is forced OFF (all 1's).\n//   A fast refresh counter flips which display is active, giving the appearance\n//   that both are lit continuously (persistence of vision).\n//\n//   Notes:\n//   - reset is treated as active-low to match the style in led_controller.sv.\n//   - REFRESH_BITS controls the per-digit refresh rate. With a ~24 MHz clock and\n//     REFRESH_BITS=14, each digit updates at ~732 Hz (overall toggle ~1.46 kHz).\n\nmodule sevenseg_dual_mux (\n    input  logic        reset,      // Active-low reset (0 = reset)\n    input  logic [3:0]  a,          // 4-bit value for Display A\n    input  logic [3:0]  b,          // 4-bit value for Display B\n    output logic [6:0]  seg_a,      // Segment lines for Display A (active-low)\n    output logic [6:0]  seg_b       // Segment lines for Display B (active-low)\n);\n\n    // -------------------------------------------------------------------------\n    // Internal clock from on-chip high-speed oscillator (same primitive as lab1)\n    // -------------------------------------------------------------------------\n    logic int_osc;\n    // Initialize high-speed oscillator; same parameters as lab1_dw.sv\n    HSOSC #(.CLKHF_DIV(2'b01)) \n        hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n\n    // -------------------------------------------------------------------------\n    // Refresh logic\n    // -------------------------------------------------------------------------\n    parameter int REFRESH_BITS = 14;  // Increase for slower toggle, decrease for faster\n    logic [REFRESH_BITS-1:0] refresh_ctr /* synthesis preserve */;\n    logic sel_digit;  // 0 =&gt; drive A, 1 =&gt; drive B\n\n    always_ff @(posedge int_osc) begin\n        if (reset == 1'b0) begin\n            refresh_ctr &lt;= '0;\n        end else begin\n            refresh_ctr &lt;= refresh_ctr + 1'b1;\n        end\n    end\n    assign sel_digit = refresh_ctr[REFRESH_BITS-1];\n\n    // -------------------------------------------------------------------------\n    // Single decoder instance (provided module: display_controller)\n    // -------------------------------------------------------------------------\n    logic [3:0] s_mux;\n    logic [6:0] seg_decoded;\n\n    // Choose which 4-bit input the decoder sees at this moment\n    assign s_mux = (sel_digit == 1'b0) ? a : b;\n\n    // One (and only one) decoder instance\n    display_controller DEC (\n        .s   (s_mux),\n        .seg (seg_decoded)\n    );\n\n    // Drive only the selected display; force the other OFF (all 1's for common anode)\n    always_comb begin\n        if (sel_digit == 1'b0) begin\n            seg_a = seg_decoded;        // Active display gets decoded segments\n            seg_b = 7'b111_1111;        // Other display off\n        end else begin\n            seg_a = 7'b111_1111;\n            seg_b = seg_decoded;\n        end\n    end\n\nendmodule\n\n// Example top-level that uses sevenseg_dual_mux with two 4-bit switch groups.\n// Replace I/O names as needed for your constraints file.\nmodule lab1_dual_top (\n    input  logic        reset,      // Active-low reset\n    input  logic [7:0]  sw,         // Eight switches: sw[3:0] -&gt; Display A, sw[7:4] -&gt; Display B\n    output logic [6:0]  seg_a,      // Seven-seg A (a..g), active-low\n    output logic [6:0]  seg_b       // Seven-seg B (a..g), active-low\n);\n\n    sevenseg_dual_mux UUT (\n        .reset (reset),\n        .a     (sw[3:0]),\n        .b     (sw[7:4]),\n        .seg_a (seg_a),\n        .seg_b (seg_b)\n    );\n\nendmodule\n\n\n\nThe provided SystemVerilog synthesized upon the inclusion of display_controller.sv from lab 1 as a source file. However, GPT-5 did not provide the instruction to do that. Something I don’t like about LLMs is that they overcomment their code, which makes it more difficult to read. However, I was impressed that the LLM managed to provide SystemVerilog that synthesized with little effort."
  }
]