[
  {
    "objectID": "posts/lab_1.html",
    "href": "posts/lab_1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs."
  },
  {
    "objectID": "posts/lab_1.html#introduction",
    "href": "posts/lab_1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs."
  },
  {
    "objectID": "posts/lab_1.html#soldering-the-development-board",
    "href": "posts/lab_1.html#soldering-the-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Soldering the Development Board",
    "text": "Soldering the Development Board\nWe were given a multitude of parts, both SMT and THT components. Soldering them to the E155 development board took approximately three hours, with the first thirty minutes spent attempting to solder the 5V regulator to the board. Figure 1 displays the completed development board.\n\n\n\nFigure 1"
  },
  {
    "objectID": "posts/lab_1.html#technical-documentation",
    "href": "posts/lab_1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the lab 1 folder of my Github repository for E155.\n\nBlock Diagram\nFigure 2 (below) contains the block diagram used to design the combinational logic to drive the LEDs and 7-segment display.\n\n\n\n\nFigure 2\n\n\n\n\nLED Control\nTable 1 contains the truth table used to determine the state of the LEDs.\n\n\n\ns[0]\ns[1]\nled[0]\ns[2]\ns[3]\nled[1]\n\n\n\n\n0\n0\nOFF\n0\n0\nOFF\n\n\n1\n0\nON\n1\n0\nOFF\n\n\n0\n1\nON\n0\n1\nOFF\n\n\n1\n1\nOFF\n1\n1\nON\n\n\n\nBy inspection of figure 2, we see that led[0] is determined by s[0] XOR s[1], and led[1] is determined by s[2] AND s[3]. In order to blink led[2] at 2.4Hz, the HSOSC module was used to create a clock with a frequency of 24MHz. I then encoded a digitally controlled oscillator, using the formula f_LED = f_clk * p / 2^N. I chose values p = 430 and N = 32, theoretically producing an oscillator with a frequency of 2.403 Hz.\n\n\n7-Segment Display Control\nThe 7-segment display is controlled by a submodule that converts the input switches (s[3:0]) into a 7-bit output (s[6:0]). The submodule contains a case statement that converts each of the 16 possible 4-bit inputs into the corresponding values needed to illuminate the 7-segment display and create the corresponding hexadecimal number. Because the 7-segment display is common anode, the necessary pins are pulled to 0 to illuminate the necessary segments. For example, the input 4’h0 is converted to 7’b1000000. s[0] corresponds to segment A and s[6] corresponds to segment G of the 7-segment display. See figure 3 for the layout.\n\n\n\nSchematic\nI consulted the datasheet of the HDSP-511A display to determine which FPGA pins I would connect to the 7-segment display. The resultant schematic can be seen below.\n\n\n\nSchematic\n\n\nIn order to keep the current draw for each segment within recommended operating conditions, I used some Ohm’s law calculations. The datasheet of the HDSP-511A display recommends a maximum forward current of 15 mA. Since the FPGA supplies 3.3V, I chose 390 Ohm resistors, which result in a current of ~8.5mA."
  },
  {
    "objectID": "posts/lab_1.html#results-and-discussion",
    "href": "posts/lab_1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\nI created testbenches for each of the submodules (led_controller.sv and display_controller.sv) as well as a testbench for the top-level module. The images below show a screenshot of the QuestaSim simulations for my top-level module.  \n\nUsing an oscilloscope, I determined that led[2] was blinking at a frequency of 2.43Hz. The image below is a picture I took of the oscilloscope, where the frequency of the waveform can be seen in the bottom right."
  },
  {
    "objectID": "posts/lab_1.html#conclusion",
    "href": "posts/lab_1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nThe development board succesfully drove the 7-segment display and controlled the three LEDs as desired. This lab took 23 hours."
  },
  {
    "objectID": "posts/lab_1.html#ai-prototype",
    "href": "posts/lab_1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\nWhen I presented ChatGPT 5 with the task of using the Lattice UP5K FPGA’s internal high-speed oscillator to blink an LED at 2Hz, the SystemVerilog it provided synthesized, but Lattice Radiant was unable to place and route the design. It attempted to use the SB_HFOSC module, but provided an alternate solution in the initial Verilog. The code block was as follows:\n// Use SB_HFOSC (recommended for iCE40UP5K)\n    SB_HFOSC #(\n        .CLKHF_DIV(HF_DIV)\n    ) u_hfosc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)\n    );\n\n    // If your toolflow expects HSOSC instead, you can swap to:\n    // HSOSC u_hfosc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk_hf));\nOnce the project failed to place and route, I commented out the block using SB_HFOSC and uncommented the block using HSOSC. Making this change enabled Lattice Radiant to succesfully place and route the design. I was impressed by the quality of the output. GPT5 avoided overcommenting, which has been an issue in the past. However, the SystemVerilog provided still contained the right amount of comments for me to easily understand it.\nGPT5 used some syntax that was unfamiliar to me. It made use of localparam int unsigned to generate integers, which I hadn’t seen in SystemVerilog before. However, the new syntax it introduced was easy enough to understand. It wouldn’t surprise me the part of the prompt I gave GPT5 that read “Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg” contributed to the quality of the Verilog it generated. Moving forward, this serves as a good example of how effective prompting of LLMs can lead to much higher quality output."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 1: FPGA and MCU Setup and Testing\n\n\n\n\n\n\n\n\nAug 27, 2025\n\n\nDiego Weiss\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Diego Weiss, a Junior Engineering major at Harvey Mudd College. My main interests fall in the fields of robotics, controls, and embedded systems. When not at school, you can find me rock climbing, hiking, backcountry snowboarding, and playing soccer with my friends."
  }
]