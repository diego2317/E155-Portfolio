---
title: "Lab 3: Keypad Scanner"
description: ""
author: "Diego Weiss"
date: "9/15/25"
categories:
  - reflection
  - labreport
draft:
---

## Introduction
The goal of this lab was to learn how to use an FPGA to scan inputs from a keypad, and then output the two most recent inputs on the multiplexed 7-segment display from lab 2. The crux of this lab was ensuring I followed synchronous design principles, as well as designing an FSM that took switch debouncing into account. The [lab 3 page](https://hmc-e155.github.io/lab/lab3/) of the E155 website has more information about the lab.

## Technical Documentation
The source code for the project can be found in the lab 3 folder of my [Github repository for E155](https://github.com/diego2317/E155).

### Circuit Design

Unlike previous labs, I began this one by designing my circuits. I made this decision because I felt like doing so would prove beneficial in going through the rest of the lab. The circuit I designed can be seen below. It features two 2N3906 PNP transistors being used to power the 7-segment display. The rational behind my design choices for the circuitry involving the transistors and the 7-segment display can be found in my [writeup for lab 2](https://diego2317.github.io/E155-Portfolio/posts/lab_2.html). 

To design my keypad scanning scheme, I made the initial decision that I would drive the rows of the keypad as outputs and read the columns as inputs. I chose to drive my rows high, which meant that to "select" a row to read I would drive it low (keeping the rest of the rows high) and read the columns. If I pressed a key in the row I was reading, it would short that row and column together, which means that a key press is represented by a low voltage level instead of a high one. I used the internal 100 kOhm resistors on the FPGA to enable this behavior. My pin assignments and general wiring are displayed in the circuits below.

![Circuit](/images/lab3/schematic.png)

### FSM

The next step I took was developing my FSM. Initially, I planned on utilizing two completely separate FSMs, one for scanning the rows and one for debouncing once a key was pressed. However, I ended up combining my initial two ideas into one big FSM, which can be seen below. In the FSM, a 1 represents a key press being detected and a 0 represents no keys being pressed. I used a counter to keep track of how many clock cycles had passed, with the counter incrementing each clock cycle. In order to deal with the delay from the synchronizer, the FSM stays in the BUFFER states for two clock cycles, which is how long it takes my synchronizer to synchronize the inputs. Whenever the FSM enters any of the ROW, PULSE, or WAIT states, the counter is reset to 0. To solve debouncing, I have the counter increment by 1 per clock cycle if it's in a DEBOUNCE state. Once counter has incremented 16 times (counter = 15), the transition can be made to the PULSE state if the key is still pressed. In the PULSE state, the FSM sends a signal called PRESS to my next-state logic. PRESS serves as a select signal to determine whether or not a new key has been pressed, which then enables the updating of the 7-segment display. My full FSM can be seen below, as well as its associated state transition table.

![FSM](/images/lab3/FSM.png)

![Truth Table](/images/lab3/state_transition_table.png)

### Block Diagram + Verilog Design

Implementing this design required 9 separate SystemVerilog modules, including the top-level module and the built-in HSOSC module for clock generation. After initializing a clock to 24 MHz using the HSOSC module, I divided the clock down to 1.2 kHz using a module of my own design. This new "slow clock" then became the system-level clock. The modules for controlling the 7-segment display were taken from lab 2, although the multiplexer module was modified to divide the clock by a factor of two instead of 2^15. This meant that the 7-segment display has a refresh rate of 600Hz, which is sufficient to not notice flickering. I chose a 1.2kHz clock so that once the FSM went through the 16 debounce clock cycles, there would be no risk that the switch was bouncing. This also meant that a button would need to be pressed for approximately 13 ms to be recognized as pressed, which I felt was reasonable. The block diagram for my system can be seen below.

![Block Diagram](/images/lab3/blockdiagram.png)


### Waveforms
Before testing my physical system, I wrote testbenches for all of my modules (except for the 7-segment display logic module, which has been the same since lab 1). This meant that once it was time to build my physical system, I was able to get it working quickly. The waveforms and testbench output for my top-level module can be seen below. The Waveform Gallery can be expanded to view the waveforms and testbench output for the rest of my modules.

![Top Level Module Testbench Waveforms](/images/lab3/top_waves.png)

![Top Level Module Testbench Output](/images/lab3/top_terminal.png)

::: {.callout-note collapse="true"}
#### Waveform Gallery

![Keypad Decoder Testbench Waveforms](/images/lab3/keypad_decoder_waves.png)

![Keypad Decoder Testbench Output](/images/lab3/keypad_decoder_terminal.png)

![Keypad Input Testbench Waveforms](/images/lab3/keypad_input_waves.png)

![Keypad Input Testbench Output](/images/lab3/keypad_input_terminal.png)

![Keypad Reader Testbench Waveforms](/images/lab3/keypad_reader_waves.png)

![Keypad Reader Testbench Output](/images/lab3/keypad_reader_terminal.png)

![Seven Segment Controller Testbench Waveforms](/images/lab3/seven_seg_controller_waves.png)

![Seven Segment Controller Testbench Output](/images/lab3/seven_seg_controller_terminal.png)

![Synchronizer Testbench Waveforms](/images/lab3/synchronizer_waves.png)

![Synchronizer Testbench Output](/images/lab3/synchronizer_terminal.png)
:::

### Conclusion

The design meets all the requirements. I spent somewhere between 25 and 30 hours on this lab.