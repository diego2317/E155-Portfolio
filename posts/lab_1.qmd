---
title: "Lab 1: FPGA and MCU Setup and Testing"
description: ""
author: "Diego Weiss"
date: "8/27/25"
categories:
  - reflection
  - labreport
draft: false
---

## Introduction
This lab involved soldering all the parts for the E155 development board. In addition, a design was implemented on the FPGA to operate a 7-segment LED display and control several other LEDs.

## Soldering the Development Board
We were given a multitude of parts, both SMT and THT components. Soldering them to the E155 development board took approximately three hours, with the first thirty minutes spent attempting to solder the 5V regulator to the board. Figure 1 displays the completed development board.

![Figure 1](/images/lab1/devboard.jpg)


## Technical Documentation
The source code for the project can be found in the lab 1 folder of my [Github repository for E155](https://github.com/diego2317/E155-labs).

### Block Diagram
Figure 2 (below) contains the block diagram used to design the combinational logic to drive the LEDs and 7-segment display. \

![Figure 2](/images/lab1/lab1_blockdiagram.jpg)

### LED Control
Table 1 contains the truth table used to determine the state of the LEDs. 

| s[0] | s[1] | led[0]| s[2] | s[3] | led[1]|
|:----:|:----:|:-----:|:----:|:----:|:-----:|
| 0    | 0    | OFF   | 0    | 0    | OFF   |
| 1    | 0    | ON    | 1    | 0    | OFF   |
| 0    | 1    | ON    | 0    | 1    | OFF   |
| 1    | 1    | OFF   | 1    | 1    | ON    |

By inspection of figure 2, we see that led[0] is determined by s[0] XOR s[1], and led[1] is determined by s[2] AND s[3]. In order to blink led[2] at 2.4Hz, the HSOSC module was used to create a clock with a frequency of 24MHz. I then encoded a digitally controlled oscillator, using the formula `f_LED = f_clk * p / 2^N`. I chose values p = 430 and N = 32, theoretically producing an oscillator with a frequency of 2.403 Hz.

### 7-Segment Display Control
The 7-segment display is controlled by a submodule that converts the input switches (s[3:0]) into a 7-bit output (s[6:0]). The submodule contains a case statement that converts each of the 16 possible 4-bit inputs into the corresponding values needed to illuminate the 7-segment display and create the corresponding hexadecimal number. Because the 7-segment display is common anode, the necessary pins are pulled to 0 to illuminate the necessary segments. For example, the input 4'h0 is converted to 7'b1000000. s[0] corresponds to segment A and s[6] corresponds to segment G of the 7-segment display. See figure 3 for the layout. \
![Figure 3](/images/lab1/7segdisplay.png){fig-align="center" height=300}

### Schematic
I consulted the [datasheet](https://www.alldatasheet.com/datasheet-pdf/view/130748/HP/HDSP-511A.html) of the HDSP-511A display to determine which FPGA pins I would connect to the 7-segment display. The resultant schematic can be seen below.

![Schematic](/images/lab1/lab1schematic_new.png)

In order to keep the current draw for each segment within recommended operating conditions, I used some Ohm's law calculations. The datasheet of the HDSP-511A display recommends a maximum forward current of 15 mA. It also notes that the LEDs have a typical forward voltage of 2.0V. In order to calculate the current across the LED, I used Ohm's law with $\Delta V = 3.3 - 2.0$ because the pins of the FPGA output 3.3V. Then, choosing 390 Ohm resistors (because they were the only ones available) results in a current of ~3.3mA across the LEDs, as seen below:
$$\frac{3.3V-2.0V}{390 \Omega} \approx 3.3 mA$$
This current proved acceptable, as all segments of the display would light up with the same brightness, regardless of how many segments were illuminated.

## Results and Discussion

### Testbench Simulation
I created testbenches for each of the submodules (`led_controller.sv` and `display_controller.sv`) as well as a testbench for the top-level module. The images below show a screenshot of the QuestaSim simulations for my top-level module. 
![Top level module waveforms](/images/lab1/lab1_dw_waveforms.png)
![Top level module testbench](/images/lab1/lab1_dw_terminal.png)
\
\
Using an oscilloscope, I determined that led[2] was blinking at a frequency of 2.43Hz. The image below is a picture I took of the oscilloscope, where the frequency of the waveform can be seen in the bottom right.
![Oscilloscope](/images/lab1/oscope.jpg)

## Conclusion
The development board succesfully drove the 7-segment display and controlled the three LEDs as desired. This lab took 23 hours.

## AI Prototype
When I presented ChatGPT 5 with the task of using the Lattice UP5K FPGA's internal high-speed oscillator to blink an LED at 2Hz, the SystemVerilog it provided synthesized, but Lattice Radiant was unable to place and route the design. It attempted to use the SB_HFOSC module, but provided an alternate solution in the initial Verilog. The code block was as follows:
```SystemVerilog
// Use SB_HFOSC (recommended for iCE40UP5K)
    SB_HFOSC #(
        .CLKHF_DIV(HF_DIV)
    ) u_hfosc (
        .CLKHFPU (1'b1),   // power up
        .CLKHFEN (1'b1),   // enable
        .CLKHF   (clk_hf)
    );

    // If your toolflow expects HSOSC instead, you can swap to:
    // HSOSC u_hfosc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk_hf));

```
Once the project failed to place and route, I commented out the block using `SB_HFOSC` and uncommented the block using `HSOSC`. Making this change enabled Lattice Radiant to succesfully place and route the design. I was impressed by the quality of the output. GPT5 avoided overcommenting, which has been an issue in the past. However, the SystemVerilog provided still contained the right amount of comments for me to easily understand it. \
GPT5 used some syntax that was unfamiliar to me. It made use of `localparam int unsigned` to generate integers, which I hadn't seen in SystemVerilog before. However, the new syntax it introduced was easy enough to understand. It wouldn't surprise me the part of the prompt I gave GPT5 that read "Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg" contributed to the quality of the Verilog it generated. Moving forward, this serves as a good example of how effective prompting of LLMs can lead to much higher quality output.